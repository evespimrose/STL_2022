===================================================================
파일 이름 : 소스.cpp
파일크기 : 1662
저장 시간 : 2022-03-02 17:11:22 GMT+9
===================================================================
파일 이름 : 소스.cpp
파일크기 : 1809
저장 시간 : 2022-03-02 17:14:58 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 2일 수요일
// 수78목23 (1주 1일)
// 
// - 강의 소개
// - cppreference.com
// - google coding convention을 참고
// - 프로젝트 환경설정 통일
// 
// 할일 - 한학기 코딩한 내용을 저장할 수 있게 save 기능 완성
//----------------------------------------------------------------------------------------

#include <iostream>
#include <string_view>
#include <filesystem>
#include <chrono>
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;

//void save(const char*)
//void save(const string&)
void save(string_view fname)
{

	// 읽을 파일을 연다
	// 쓸 파일을 연다.
	ifstream in{ fname.data() };
	ofstream out{ "2022.1학기 STL 수78목23 강의저장.txt" , ios::app };

	// 저장할 파일 이름과 크기를 출력한다.
	out << "===================================================================" << endl;
	out << "파일 이름 : " << fname << endl;
	out << "파일크기 : " << filesystem::file_size(fname) << endl;

	// 현재 날짜와 시간(C++20)을 출력한다.
	auto time = floor<chrono::seconds>(chrono::system_clock::now());
	out << "저장 시간 : " << chrono::zoned_time("Asia/Seoul", time) << endl;

	// 읽은 파일을 강의저장 파일에 덧붙인다.
	// 1. 벡터에 파일을 읽어온다.
	//vector<char> v{ istream_iterator<char>{in},{} };
	vector<char> v{ istreambuf_iterator<char>{in},{} };

	// 2. copy 알고리즘을 이용해 벡터에 있는 글자를 가으이저장파일로 복사한다,
	copy(v.begin(), v.end(), ostream_iterator<char>{out});
}

int main()
{
	// string과 string_view의 크기 확인
	// 서로의 크기가 다른 이유?
	string a;
	string_view b;
	cout << "string의 크기 - " << sizeof(a) << endl << "string_view의 크기 - " << sizeof(b) << endl;
	save("소스.cpp");
}
===================================================================
파일 이름 : 소스.cpp
파일크기 : 692
저장 시간 : 2022-03-03 10:47:27 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일
// 수78목23 (1주 2일)
// 
// 
// 할일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <string_view>
#include <filesystem>
#include <chrono>
#include <fstream>
#include <vector>
#include <algorithm>

#include "save.h"

using namespace std;

int main()
{
	string a;
	string_view b;
	cout << "string의 크기 - " << sizeof(a) << endl << "string_view의 크기 - " << sizeof(b) << endl;
	save("소스.cpp");
}
===================================================================
파일 이름 : save.h
파일크기 : 76
저장 시간 : 2022-03-03 11:03:43 GMT+9
#pragma once

#include <string_view>

void save(std::string_view fname);===================================================================
파일 이름 : save.cpp
파일크기 : 1563
저장 시간 : 2022-03-03 11:03:43 GMT+9
//----------------------------------------------------------------------------------------
// SAVE.CPP
// 
// 이 함수를 호출하면 "2022.1학기 STL 수78목23 강의저장.txt"에
// 전달된 이름의 파일을 읽어 덧붙인다.
// 2022. 3. 3								BY JHT
//----------------------------------------------------------------------------------------

#include <iostream>
#include <filesystem>
#include <chrono>
#include <fstream>
#include <vector>
#include <algorithm>

#include "save.h"

//void save(const char*)
//void save(const string&)
void save(std::string_view fname)
{

	// 읽을 파일을 연다 - RALL
	std::ifstream in{ fname.data() };


	// 쓸 파일을 연다.
	std::ofstream out{ "2022.1학기 STL 수78목23 강의저장.txt" , std::ios::app };

	// 저장할 파일 이름과 크기(C++17)를 출력한다.
	out << "===================================================================" << std::endl;
	out << "파일 이름 : " << fname << std::endl;
	out << "파일크기 : " << std::filesystem::file_size(fname) << std::endl;

	// 현재 날짜와 시간(C++20)을 출력한다.
	auto time = floor<std::chrono::seconds>(std::chrono::system_clock::now());
	out << "저장 시간 : " << std::chrono::zoned_time("Asia/Seoul", time) << std::endl;

	// 읽은 파일을 강의저장 파일에 덧붙인다.

	// 1. 벡터에 파일을 읽어온다. - 컨테이너
	//vector<char> v{ istream_iterator<char>{in},{} };
	std::vector<char> v{ std::istreambuf_iterator<char>{in},{} };

	// 2. copy 알고리즘을 이용해 벡터에 있는 글자를 강의저장파일로 복사한다,
	copy(v.begin(), v.end(), std::ostream_iterator<char>{out});
}===================================================================
파일 이름 : 소스.cpp
파일크기 : 475
저장 시간 : 2022-03-03 11:03:43 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일
// 수78목23 (1주 2일)
// 
// 
// 할일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
//----------------------------------------------------------------------------------------

#include <iostream>

#include "save.h"

using namespace std;

int main()
{
	save("save.h");
	save("save.cpp");
	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 687
저장 시간 : 2022-03-03 11:19:56 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일
// 수78목23 (1주 2일)
// 
// 
// 할일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
//----------------------------------------------------------------------------------------

#include <iostream>

#include "save.h"

using namespace std;

void change(int& a, int& b)
{
	int tmp;
	tmp = a;
	a = b;
	b = tmp;
}

// [문제] main()을 변경하면 안된다.
// 실행하면 a와 b의 값이 서로 바껴야 한다.
//

int main()
{
	int a{ 1 };
	int b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;

	save("소스.cpp");
}
===================================================================
파일 이름 : 소스.cpp
파일크기 : 1013
저장 시간 : 2022-03-03 11:37:24 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일
// 수78목23 (1주 2일)
// 
// 
// 할일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
//----------------------------------------------------------------------------------------

#include <iostream>

#include "save.h"

using namespace std;

// 교수님 답
void change(int&, int&);

// 내 답
//void change(int& a, int& b)
//{
//	int tmp{};
//	tmp = a;
//	a = b;
//	b = tmp;
//}

// [문제] main()을 변경하면 안된다.
// 실행하면 a와 b의 값이 서로 바껴야 한다.
// 참조인자로 전달하지 않으면 매개변수를 복사본으로 전달해 함수에서 바꾸어도 원본인 변수의 값은 변경되지 않는다.
// 클래스 안에서 레퍼런스는 복사본이 아닌 원본을 이용하라는 뜻이다.

int main()
{
	int a{ 1 };
	int b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;

	save("소스.cpp");
}

void change(int& a, int& b)
{
	int tmp{};
	tmp = a;
	a = b;
	b = tmp;
}


===================================================================
파일 이름 : 소스.cpp
파일크기 : 1063
저장 시간 : 2022-03-03 12:17:48 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일
// 수78목23 (1주 2일)
// 
// 
// 할일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
// &의 의미를 복습
// class를 복습
// 
//----------------------------------------------------------------------------------------

#include <iostream>

#include "save.h"

using namespace std;

class Dog
{
	int a;
public:
	Dog() {};
	//Dog(int i) { a = i; };
	Dog(int i) : a{ i } {};

	friend ostream& operator<<(ostream&, const Dog& );
};

ostream& operator<<(ostream& os, const Dog& d)
{
	os << d.a;
	return os;
}

template<typename T>
void change(T& a, T& b)
{
	T tmp{};
	tmp = a;
	// 클래스가 선언될 때, operator=은 자동으로 생성된다. 
	// a.operator=(b);
	a = b;
	b = tmp;
}

// [문제] main()을 변경하면 안된다.
// 실행하면 a와 b의 값이 서로 바껴야 한다.

int main()
{
	Dog a{ 1 };
	Dog b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;

	save("소스.cpp");
}



===================================================================
파일 이름 : 소스.cpp
파일크기 : 1128
저장 시간 : 2022-03-03 12:20:21 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일
// 수78목23 (1주 2일)
// 
// 
// 할일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
// &의 의미를 복습
// class를 복습
// 
//----------------------------------------------------------------------------------------

#include <iostream>

#include "save.h"

using namespace std;

class Dog
{
	int a;
public:
	Dog() {};
	//Dog(int i) { a = i; };
	Dog(int i) : a{ i } {};

	//friend ostream& operator<<(ostream&, const Dog& );
	
	// 야매기술
	operator int() {
		return a;
	}
};

//ostream& operator<<(ostream& os, const Dog& d)
//{
//	os << d.a;
//	return os;
//}

template<typename T>
void change(T& a, T& b)
{
	T tmp{};
	tmp = a;
	// 클래스가 선언될 때, operator=은 자동으로 생성된다. 
	// a.operator=(b);
	a = b;
	b = tmp;
}

// [문제] main()을 변경하면 안된다.
// 실행하면 a와 b의 값이 서로 바껴야 한다.

int main()
{
	Dog a{ 1 };
	Dog b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;

	save("소스.cpp");
}



===================================================================
파일 이름 : 소스.cpp
파일크기 : 926
저장 시간 : 2022-03-10 10:38:44 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 10일 목요일
// 수78목23 (2주 1일)
// 
// 
// 할일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
// &의 의미를 복습
// class를 복습
// 
//----------------------------------------------------------------------------------------

#include <iostream>

#include "save.h"

using namespace std;

template<typename T>
void change(T& a, T& b)
{
	T tmp{};
	tmp = a;
	// 클래스가 선언될 때, operator=은 자동으로 생성된다. 
	// a.operator=(b);
	a = b;
	b = tmp;
}

// [문제] change를 한번만 선언하고 정의하여 
// main이 수정 없이 실행되도록 해보자.

int main()
{
	{
		
		int a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << endl;
	}
	{
		string a{ "1"s }, b{ "2"s };
		change(a, b);
		cout << a << ", " << b << endl;
	}

	save("소스.cpp");
}



===================================================================
파일 이름 : 소스.cpp
파일크기 : 1269
저장 시간 : 2022-03-10 11:46:28 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 10일 목요일
// 수78목23 (2주 1일)
// 
// 
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 C++ 핵심 keyword
//		  - 이러한 방식의 코딩을 generic 
// 
// 많은 데이터를 다루는 연습 - 파일
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <ctime>
#include "save.h"

using namespace std;

// [문제] 엔진과 분포를 이용하여 임의의 값을 갖는 int 1000개를 화면에 출력하라.
random_device rd;
default_random_engine dre{ rd() };

int main()
{
	std::uniform_int_distribution uid;

	for (int i = 0; i < 1000; ++i)
	{
		cout << uid(dre) << "\t";
	}
	cout << endl;

	save("소스.cpp");
}

//int main()
//{
//
//	srand(time(NULL));
//
//	int a[1000]{};
//
//	for (int i : a)
//	{
//		i = rand();
//		cout << i << "\t";
//	}
//
//	//save("소스.cpp");
//}

//int main()
//{
//	std::random_device rd;
//	std::mt19937 gen(rd());
//	std::uniform_int_distribution<int> dis(0, 10000000);
//
//	int a[1000]{};
//
//	for (int i : a)
//	{
//		i = dis(gen);
//		cout << i << "\t";
//	}
//
//	//save("소스.cpp");
//}



===================================================================
파일 이름 : 소스.cpp
파일크기 : 1298
저장 시간 : 2022-03-10 11:54:42 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 10일 목요일
// 수78목23 (2주 1일)
// 
// 
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 C++ 핵심 keyword
//		  - 이러한 방식의 코딩을 generic 
// 
// 많은 데이터를 다루는 연습 - 파일
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;

// [문제] int의 최댓값 출력

int main()
{
	

	//1
	cout << "int의 최댓값 : " << numeric_limits<int>::max() << endl;
	cout << "unsigned int의 최댓값 : " << numeric_limits<unsigned int>::max() << endl;

	//2
	int num = 0x7F'FF'FF'FF;
	cout << "int의 최댓값 : " << num << endl;

	//3
	cout << "int의 최댓값 : " << INT_MAX << endl;

	save("소스.cpp");
}

//int main()
//{
//
//	srand(time(NULL));
//
//	int a[1000]{};
//
//	for (int i : a)
//	{
//		i = rand();
//		cout << i << "\t";
//	}
//
//	//save("소스.cpp");
//}

//int main()
//{
//	std::random_device rd;
//	std::mt19937 gen(rd());
//	std::uniform_int_distribution<int> dis(0, 10000000);
//
//	int a[1000]{};
//
//	for (int i : a)
//	{
//		i = dis(gen);
//		cout << i << "\t";
//	}
//
//	//save("소스.cpp");
//}



===================================================================
파일 이름 : 소스.cpp
파일크기 : 1027
저장 시간 : 2022-03-16 15:31:05 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일
// 수78목23 (2주 2일)
// 
// 
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 C++ 핵심 keyword
//		  - 이러한 방식의 코딩을 generic 
// 
// 많은 데이터를 다루는 연습 - 파일
// 숙제 - 파일입출력 알아보기
// 다음시간 질문 - int 1000개를 저장하려면 몇 바이트가 필요할까?
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include "save.h"

using namespace std;

// [문제] 엔진과 분포를 이용하여 임의의 값을 갖는 int 1000개를 화면에 출력하라.
// 마지막 int값은 1515792703을 출력
// 1515792703

int main()
{
	ifstream in{ "random int 1000s.txt" };

	if (!in)
	{
		cout << "파일을 열 수 없습니다." << endl;
		return 0;
	}
	int num;

	for (int i = 0; i < 1000; ++i)
	{
		in >> num;
		cout << num << "\t";
	}
	


	save("소스.cpp");
}


===================================================================
파일 이름 : 소스.cpp
파일크기 : 1543
저장 시간 : 2022-03-16 15:53:18 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일
// 수78목23 (2주 2일)
// 
// 
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 C++ 핵심 keyword
//		  - 이러한 방식의 코딩을 generic 
// 
// 많은 데이터를 다루는 연습 - 파일
// 숙제 - 파일입출력 알아보기
// 다음시간 질문 - int 1000개를 저장하려면 몇 바이트가 필요할까?
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <cmath>
#include "save.h"

using namespace std;

// [문제] 엔진과 분포를 이용하여 임의의 값을 갖는 int 1000개를 화면에 출력하라.
// 가장 큰 값을 찾아 화면에 출력해보자.

int main()
{
	ifstream in{ "random int 1000s.txt" };

	if (!in)
	{
		cout << "파일을 열 수 없습니다." << endl;
		return 0;
	}

	// 교수님
	{
		int num;
		int max{ numeric_limits<int>::min() };

		for (int i{}; i < 1000; ++i)
		{
			in >> num;
			if (max < num) max = num;
		}

		cout << max << endl;
	}

	// 교수님 2

	cout << *max_element(istream_iterator<int>{in}, {}) << endl;

	//1
	{
		int num;
		int M = 0;
		for (int i = 0; i < 1000; ++i)
		{
			in >> num;
			M = std::max(M, num);
		}
		cout << M << endl;
	}
	//2
	{
		int num;
		int M = 0;
		for (int i = 0; i < 1000; ++i)
		{
			in >> num;
			if (M < num) M = num;
		}

		cout << M << endl;
	}

	// ?? 왜다르지?
	// 2147255967
	// 1515792703

	save("소스.cpp");
}



===================================================================
파일 이름 : 소스.cpp
파일크기 : 938
저장 시간 : 2022-03-16 16:03:59 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일
// 수78목23 (2주 2일)
// 
// 
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 C++ 핵심 keyword
//		  - 이러한 방식의 코딩을 generic 
// 
// 많은 데이터를 다루는 연습 - 파일
// 숙제 - 파일입출력 알아보기
// 다음시간 질문 - int 1000개를 저장하려면 몇 바이트가 필요할까?
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <cmath>
#include "save.h"

using namespace std;

// [문제] 
// int 1000개를 저장하려면 메모리 몇 바이트가 필요합니까?
// 답
// 대답할 수 없다. 제한이 없다. 왜 없을까?
//	-> 상황에 따라 다르다.
//	-> 그렇지만 int 메모리 자체 비트를 그대로 기록하고 읽어온다면 어떤 상황에서도 4000 Byte면 충분할 것이다. 

int main()
{

	save("소스.cpp");
}



===================================================================
파일 이름 : 소스.cpp
파일크기 : 1158
저장 시간 : 2022-03-16 16:19:21 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일
// 수78목23 (2주 2일)
// 
// 
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 C++ 핵심 keyword
//		  - 이러한 방식의 코딩을 generic 
// 
// 많은 데이터를 다루는 연습 - 파일
// 숙제 - 파일입출력 알아보기
// 다음시간 질문 - int 1000개를 저장하려면 몇 바이트가 필요할까?
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

using namespace std;

// [문제] 
// int 1000개를 파일에 메모리 그대로 기록하라. 파일 이름은 그대로 유지하라.

int main()
{
	ofstream out{ "random int 1000s.txt", ios::binary };
	// 이상한점?
	// 4000 바이트일줄 알았는데 4004 바이트가 나왔다. 왜?
	// 윈도우는 파일을 기록할 때 어떤 데이터에서는 1바이트를 2바이트로 저장한다 그것은 아스키 코드 enter. CR,LF를 누르면 2바이트로 저장한다.
	// ios::binary 를 붙이면 4바이트가 사라진다.

	int num;

	for (int i = 0; i < 1000; ++i)
	{
		num = i + 1;
		out.write((const char*)&num, sizeof(num));
	}

	save("소스.cpp");
}



===================================================================
파일 이름 : 소스.cpp
파일크기 : 1886
저장 시간 : 2022-03-16 17:17:21 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일
// 수78목23 (2주 2일)
// 
// 
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 C++ 핵심 keyword
//		  - 이러한 방식의 코딩을 generic 
// 
// 많은 데이터를 다루는 연습 - 파일
// 숙제 - 파일입출력 알아보기
// 다음시간 질문 - int 1000개를 저장하려면 몇 바이트가 필요할까?
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <format>		// c++20
#include <cmath>
#include <array>
#include "save.h"

using namespace std;

// [문제] 
// 랜덤 값 int 1000개를 파일에 메모리 그대로 기록하라. 
// 이 때, 바이너리 모드로 기록하면 쓸데없는 변환을 안하도록 할 수 있다.
// random int 1000s.txt 파일에 binary 모드와 write 함수를 사용하여 기록되었다.
// 읽어서 가장 큰 값을 찾아 화면에 출력하라.

int main()
{
	ifstream in{ "random int 1000s.txt", ios::binary };
	

	{
		/*int num;
		int max{ numeric_limits<int>::min() };

		for (int i = 0; i < 1000; ++i)
		{
			in.read((char*)&num, sizeof(num));
			max = std::max(num, max);
		}
		cout << max << endl;*/
	}

	{
		int num[1'000];
		in.read((char*)num, sizeof(int) * 1'000);
		{
			/*for (int num : num)
				cout << num << "\t";
			cout << endl;*/
		}
		{
			for (int num : num)
				cout << format("{:20}", num);
		}
		cout << endl;
		cout << *max_element(begin(num), end(num)) << endl;
	}
	{
		//int num[1'000];
		array<int, 1000> num;

		in.read((char*)num.data(), sizeof(int) * 1'000);
		{
			/*for (int num : num)
				cout << num << "\t";
			cout << endl;*/
		}
		{
			for (int num : num)
				cout << format("{:20}", num);
		}
		cout << endl;
		cout << *max_element(begin(num), end(num)) << endl;
	}

	save("소스.cpp");
}



===================================================================
파일 이름 : 소스.cpp
파일크기 : 873
저장 시간 : 2022-03-17 11:31:25 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 17일 목요일
// 수78목23 (3주 1일)
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;

// [문제] 
// 사용자 입력을 받아 원하는 만큼 int를 저장할 메모리를 확보하고 1부터 증가하는 정수로 메모리를 채워라.
// 전체 합계를 출력하라.

int main()
{
	save("소스.cpp");

	while(true) 
	{
		int num;
		cout << "몇 개를 원하십니까? : ";
		cin >> num;

		unique_ptr<int[]> p{new int[num]};

		for (int i = 0; i < num; ++i)
		{
			p[i] = i + 1;
		}

		long long sum{};

		for (int i = 0; i < num; ++i)
		{
			sum += p[i];
		}

		cout << "1 부터" << num << "까지의 합계 : " << sum << endl << endl;

		p.reset(nullptr);
	}
}



===================================================================
파일 이름 : 소스.cpp
파일크기 : 1040
저장 시간 : 2022-03-17 12:05:28 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 17일 목요일
// 수78목23 (3주 1일)
// 
// - 지난 시간 배운 것 - 앞으로 int[100] 대신에 -> array<int,100> 사용하자
// - 오늘 알아본 것 - 앞으로 int* 대신에 -> unique_ptr<int> 사용하자
//					- int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자 
//----------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;

// 메모리 관찰용 초미니 Dog를 만들자

struct Dog
{
	Dog() { cout << "Dog 생성자 호출" << endl; }
	~Dog() { cout << "Dog 소멸자 호출" << endl; }
};

// [문제] 
// 
// 

void f()
{
	throw 1;
}

int main()
{
	save("소스.cpp");

	/*for (int i = 0; i < 3; ++i)
	{
		Dog* p = new Dog;
		delete p;
	}*/
	unique_ptr<Dog[]>p{new Dog[3]};

	// 여기서 비정상 종료
	try
	{
		f();		// 예외를 던진다
	}
	catch (...)		// ... elipses
	{
		cout << "예외를 잡았다" << endl;
		return 0;
	}
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 802
저장 시간 : 2022-03-17 12:09:09 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 17일 목요일
// 수78목23 (3주 1일)
// 
// - 지난 시간 배운 것 - 앞으로 int[100] 대신에 -> array<int,100> 사용하자
// - 오늘 알아본 것 - 앞으로 int* 대신에 -> unique_ptr<int> 사용하자
//					- int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

using namespace std;

// [문제] 이 "소스.cpp" 파일의 소문자를 전부 대문자로 바꿔
// "소스 대문자.cpp"로 저장하라.

int main()
{
	ifstream in("소스.cpp");

	char c;
	while (in >> noskipws >> c)
	{
		c = toupper(c);
		cout << c << endl;
	}

	save("소스.cpp");
}


===================================================================
파일 이름 : 소스.cpp
파일크기 : 829
저장 시간 : 2022-03-17 12:10:23 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 17일 목요일
// 수78목23 (3주 1일)
// 
// - 지난 시간 배운 것 - 앞으로 int[100] 대신에 -> array<int,100> 사용하자
// - 오늘 알아본 것 - 앞으로 int* 대신에 -> unique_ptr<int> 사용하자
//					- int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

using namespace std;

// [문제] 이 "소스.cpp" 파일의 소문자를 전부 대문자로 바꿔
// "소스 대문자.cpp"로 저장하라.

int main()
{
	ifstream in("소스.cpp");
	ofstream out("소스 대문자.cpp");

	char c;
	while (in >> noskipws >> c)
	{
		c = toupper(c);
		out << c ;
	}

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1250
저장 시간 : 2022-03-23 16:08:32 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 23일 수요일
// 수78목23 (3주 2일)
// 
// 지난 시간 : RAII / stack unwinding
// 
// 이번 시간 : 호출가능(Callable) 타입 -  예제는 정렬(sort)
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// String 클래스를 만들어 나가면서 STL을 이해해본다.
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

using namespace std;

// [문제] 이 "소스.cpp" 파일의 소문자를 전부 대문자로 바꿔
// "소스 대문자.cpp"로 저장하라.

int main()
{


	ifstream in("소스.cpp");
	ofstream out("소스 대문자.cpp");

	in >> noskipws;

	if(false) {
		// c 함수 사용 방식
		char c;
		while (in >> c)
		{
			if (islower(c))
				c = toupper(c);
			out << c;
		}
	}
	{
		// STL 사용 방식
		//transform(어디부터, 어디까지를, 저기에 저장, 이렇게 바꿔서)
		//transform(istreambuf_iterator<char>{in}, {}, ostreambuf_iterator{ out }, toupper);
		transform(istreambuf_iterator<char>{in}, {}, ostreambuf_iterator{ out }, [](char c) {return toupper(c); });

	}
	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1282
저장 시간 : 2022-03-23 16:10:58 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 23일 수요일
// 수78목23 (3주 2일)
// 
// 지난 시간 : RAII / stack unwinding
// 
// 이번 시간 : 호출가능(Callable) 타입 -  예제는 정렬(sort)
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// String 클래스를 만들어 나가면서 STL을 이해해본다.
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

using namespace std;

// [문제] 이 "소스.cpp" 파일의 
// 숫자를 *로 바꿔라.
// "소스 대문자.cpp"로 저장하라.

int main()
{


	ifstream in("소스.cpp");
	ofstream out("소스 대문자.cpp");

	in >> noskipws;

	if(false) {
		// c 함수 사용 방식
		char c;
		while (in >> c)
		{
			if (islower(c))
				c = toupper(c);
			out << c;
		}
	}
	{
		// STL 사용 방식
		//transform(어디부터, 어디까지를, 저기에 저장, 이렇게 바꿔서)
		//transform(istreambuf_iterator<char>{in}, {}, ostreambuf_iterator{ out }, toupper);
		transform(istreambuf_iterator<char>{in}, {}, ostreambuf_iterator{ cout }, [](char c) {
			if (isdigit(c))
				c = '*';
			return c; 
			});

	}
	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1492
저장 시간 : 2022-03-23 16:53:19 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 23일 수요일
// 수78목23 (3주 2일)
// 
// 지난 시간 : RAII / stack unwinding
// 
// 이번 시간 : 호출가능(Callable) 타입 -  예제는 정렬(sort)
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// String 클래스를 만들어 나가면서 STL을 이해해본다.
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <array>
#include <format>
#include <random>
#include <algorithm>
#include "save.h"

using namespace std;

// [문제] 랜덤값을 갖는 int 100개를 생성하라.
// 오름차순으로 정렬하라.
// 화면에 정렬된 int 100개를 출력하라.

default_random_engine dre;

int main()
{
	std::uniform_int_distribution uid(0,100);

	array<int, 100> ai;

	{
		/*for (int i = 0; i < ai.size(); ++i)
		{
			ai[i] = uid(dre);
		}*/
		for (int& random_number : ai)
		{
			random_number = uid(dre);
		}
		cout << "정렬 전 데이터" << endl;
		for (int num : ai)
		{
			cout << format("{:4}", num);
		}
		cout << endl << "정렬 후 데이터" << endl;
		sort(ai.begin(), ai.end());
		for (int num : ai)
		{
			cout << format("{:4}", num);
		}
	}

	{
		//vector<int> vi;

		/*for (int i = 0; i < 100; ++i)
		{
			vi.push_back(uid(dre));
		}

		sort(vi.begin(), vi.end());

		for (int i : vi)
			cout << i << endl;*/
	}
	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 809
저장 시간 : 2022-03-23 17:10:23 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 23일 수요일
// 수78목23 (3주 2일)
// 
// 지난 시간 : RAII / stack unwinding
// 
// 이번 시간 : 호출가능(Callable) 타입 -  예제는 정렬(sort)
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// String 클래스를 만들어 나가면서 STL을 이해해본다.
// 
//----------------------------------------------------------------------------------------

#include <iostream>

#include "save.h"

using namespace std;

// [문제] 

void f()
{
	cout << "함수가 호출되었다" << endl;
}

int main()
{
	f();

	// f의 자료형을 출력하라.
	cout << typeid(f).name() << endl;
	cout << addressof(f) << endl;
	cout << addressof(main) << endl;

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1173
저장 시간 : 2022-03-24 10:42:54 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 24일 목요일
// 수78목23 (4주 1일)
// 
// 지난 시간 : RAII / stack unwinding
// 
// 이번 시간 : 호출가능(Callable) 타입 -  예제는 정렬(sort)
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// String 클래스를 만들어 나가면서 STL을 이해해본다.
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"

using namespace std;

// [문제] 

void jump()
{
	cout << "짬푸!" << endl;
}

void slide()
{
	cout << "슬라이드!" << endl;
}

int g;

int main()
{
	// 확인 : 함수의 이름은 함수가 기록되어 있는 CODE 세그먼트의 시작번지이다.
	// 함수들은 유사한 메모리에 기록되어 있음을 알 수 있다.

	cout << "main : " << addressof(main) << endl;
	cout << "save : " << addressof(save) << endl;
	cout << "jump : " << addressof(jump) << endl;
	cout << "slide : " << addressof(slide) << endl;

	int n;
	cout << "STACK : " << addressof(n) << endl;
	cout << "DATA : " << addressof(g) << endl;

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 774
저장 시간 : 2022-03-24 10:45:57 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 24일 목요일
// 수78목23 (4주 1일)
// 
// 지난 시간 : RAII / stack unwinding
// 
// 이번 시간 : 호출가능(Callable) 타입 -  예제는 정렬(sort)
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// String 클래스를 만들어 나가면서 STL을 이해해본다.
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;

// [문제] 

int main()
{
	int n[25000];
	for (int i = 0; i < 25000; ++i)
	{
		n[i] = i * i;
	}
	cout << "메인 호출" << endl;

	for (int i = 0; i < 25000; ++i)
		cout << i << endl;

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 881
저장 시간 : 2022-03-24 11:00:58 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 24일 목요일
// 수78목23 (4주 1일)
// 
// 지난 시간 : RAII / stack unwinding
// 
// 이번 시간 : 호출가능(Callable) 타입 -  예제는 정렬(sort)
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// String 클래스를 만들어 나가면서 STL을 이해해본다.
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;

// [문제] 
// 호출가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나?
// 1. 함수 - CODE 세그먼트에 기록된 명령어 집합의 시작번지
// 2. 람다 - 이름 없는 함수
//


int main()
{
	//lambda
	cout << typeid([]() {
		cout << "안녕! 난 람다야! 하위!" << endl;
		}()).name() << endl;



	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1450
저장 시간 : 2022-03-24 11:08:28 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 24일 목요일
// 수78목23 (4주 1일)
// 
// 지난 시간 : RAII / stack unwinding
// 
// 이번 시간 : 호출가능(Callable) 타입 -  예제는 정렬(sort)
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// String 클래스를 만들어 나가면서 STL을 이해해본다.
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;

// [문제] 
// 호출가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나?
// 1. 함수 - CODE 세그먼트에 기록된 명령어 집합의 시작번지
// 2. 람다 - 이름 없는 함수
//

class Cat {};

auto x2 = []() {
	cout << "안녕! 난 람다야! 하위!" << endl;
};

int main()
{
	class Dog {};




	//lambda
	auto x = []() {
		cout << "안녕! 난 람다야! 하위!" << endl;
	};

	auto x1 = []() {
		cout << "안녕! 난 람다야! 하위!" << endl;
	};

	cout << typeid(Dog).name() << endl;
	// class `int __cdecl main(void)'::`2'::Dog
	cout << typeid(Cat).name() << endl;
	// class Cat
	cout << typeid(x).name() << endl;
	//class `int __cdecl main(void)'::`2'::<lambda_1>
	cout << typeid(x1).name() << endl;
	//class `int __cdecl main(void)'::`2'::<lambda_2>
	cout << typeid(x2).name() << endl;
	//class x2::<lambda>

	// 람다함수는 클래스로 구현되어 있음.


	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1126
저장 시간 : 2022-03-24 11:18:19 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 24일 목요일
// 수78목23 (4주 1일)
// 
// 지난 시간 : RAII / stack unwinding
// 
// 이번 시간 : 호출가능(Callable) 타입 -  예제는 정렬(sort)
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// String 클래스를 만들어 나가면서 STL을 이해해본다.
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <array>

#include "save.h"

using namespace std;

// [문제] 
// 호출가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나?
// 1. 함수 - CODE 세그먼트에 기록된 명령어 집합의 시작번지
// 2. 람다 - 이름 없는 함수
// 3. 클래스 객체 - 
//

class Dog {
public:
	bool operator()(int a, int b) {
		cout << "Dog 호출" << endl;
		cout << a << " 비교 " << b << endl;
		return a > b;
	}
};

int main()
{
	array<int, 5> arr{1,3,5,2,4};

	sort(arr.begin(), arr.end(), Dog());
	for (int i : arr)
	{
		cout << i << " ";
	}
	cout << endl;

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1138
저장 시간 : 2022-03-24 11:39:14 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 24일 목요일
// 수78목23 (4주 1일)
// 
// 지난 시간 : RAII / stack unwinding
// 
// 이번 시간 : 호출가능(Callable) 타입 -  예제는 정렬(sort)
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// String 클래스를 만들어 나가면서 STL을 이해해본다.
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <functional>

#include "save.h"

using namespace std;

// [문제] 
// 호출가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나?
// 1. 함수포인터 - CODE 세그먼트에 기록된 명령어 집합의 시작번지
// 2. 람다 - 이름 없는 함수, 실제는 클래스로 구현된다.
// 3. operator()을 오버로딩한 클래스
// 4. 멤버 함수를 가리키는 포인터
// 
// - 호출 가능 타입의 종류가 무한하기 때문에
// 모든 호출가능타입을 대표하는 클래스를 만들었다. : function
//

int add(int a, int b)
{
	return a + b;
}


int main()
{
	function<int(int, int)> f;

	f = add;

	cout << f(3, 3) << endl;


	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1011
저장 시간 : 2022-03-30 16:35:47 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 30일 수요일
// 수78목23 (4주 2일)
// 
// 지난 시간 : RAII / stack unwinding
// 
// 이번 시간 : 호출가능(Callable) 타입 -  예제는 정렬(sort)
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// String 클래스를 만들어 나가면서 STL을 이해해본다.
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <functional>
#include <string>

#include "save.h"
#include "STRING.h"

using namespace std;

// [문제] main()이 문제없이 실행되도록 class STRING을 코딩하라.
// special 함수는 동작을 관찰하도록 cout으로 메모리와 동작을 코딩한다.
// 객체 생성 시 고유번호를 갖도록 한다.

int main()
{	
	관찰 = true;
	STRING a{ "2022 1학기" };
	STRING b{ "STL" };
	STRING c = a + b;

	cout << a << endl;
	cout << b << endl;
	cout << c << endl;

	save("소스.cpp");
	save("STRING.h");
}

===================================================================
파일 이름 : STRING.h
파일크기 : 1938
저장 시간 : 2022-03-30 16:35:47 GMT+9
#pragma once
bool 관찰{false};

class STRING {
	// 페딩 4바이트 속도를 위해 비워둠
	int id;								// 생성 시 부여
	size_t num;							// 확보한 자원의 수
	char* p;							// 확보한 자원의 위치
	static int cid;						// 객체가 생성될 때마다 1 증가

public:
	STRING() : num{}, p{}, id{cid++}
	{
		if (관찰)
		{
			print("디폴트");
		}
	};
	STRING(const char* s) : num{ strlen(s) } , id{++cid}
	{
		p = new char[num];

		memcpy(p, s, num);

		// 관찰메시지를 켜면 출력한다.
		std::cout << "ctor [" << id << "] " << this << std::endl;

		if (관찰)
		{
			print("생성자(*)");
		}
	};
	~STRING() {
		// 관찰메시지를 켜면 출력한다.
		std::cout << "dtor [" << id << "] " << this << std::endl;

		if (관찰)
		{
			print("소멸자");
		}

		if(num)
			delete[] p;
	}

	STRING(const STRING& other) : num{other.num}, id{++cid}
	{
		p = new char[other.num];
		memcpy(p, other.p, num);
		if (관찰)
		{
			print("복사생성");
		}
	}

	STRING operator+(const STRING& rhs) const
	{
		STRING tmp;
		
		tmp.num = num + rhs.num;
		tmp.p = new char[num + rhs.num];

		memcpy(tmp.p, p, num);
		memcpy(tmp.p + num, rhs.p, rhs.num);
		
		return tmp;
	}

	STRING operator=(const STRING& other)
	{
		if (this == &other)
			return *this;

		if (num)
			delete[] p;

		num = other.num;
		p = new char[num];

		memcpy(p, other.p, num);

		if (관찰)
			print("복사할당");

		return *this;
	}

	void print(const char* s)
	{
		std::cout << s << ", [" << id << "] 객체 : " << this;
		if (num)
		{
			std::cout << " 자원 수 : " << num << " 주소 : " << (void*)p;
		}
		else
		{
			std::cout << " 자원없음";
		}
		std::cout << std::endl;
	}

private:
	friend std::ostream& operator<<(std::ostream&, const STRING&);


};

int STRING::cid{};

std::ostream& operator<<(std::ostream& os, const STRING& s)
{
	for (int i = 0; i < s.num; ++i)
		os << s.p[i];
	return os;
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 749
저장 시간 : 2022-03-30 17:07:26 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 30일 수요일
// 수78목23 (4주 2일)
//
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <array>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] 

int main()
{	
	관찰 = true;

	array<STRING, 3> a{ "2022년", "3월", "30일" };
	
	for (auto& x : a)
	{
		cout << x << endl;
	}

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1085
저장 시간 : 2022-03-30 17:19:48 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 30일 수요일
// 수78목23 (4주 2일)
//
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] 

int main()
{	
	// 복사생성자 최소화
	관찰 = true;

	array<STRING, 3> a{ "2022년", "3월", "30일" };

	// a를 글자수 기준 오름차순으로 정렬한 후 출력

	sort(a.begin(), a.end(), [](STRING l, STRING r) {return l.getNum() < r.getNum(); });

	//sort(a.begin(), a.end(), [](STRING l, STRING r) {return l < r; });

	
	/*for (STRING& x : a)
	{
		cout << x << endl;
	}*/

	for (int i{}; i < a.size(); ++i)
	{
		cout << a[i] << endl;
	}

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1009
저장 시간 : 2022-03-31 10:35:37 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 30일 수요일
// 수78목23 (4주 2일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] 

int main()
{	
	// 복사생성자 최소화
	//관찰 = true;

	array<STRING, 3> a{ "2022년", "3월", "30일" };

	// a를 글자수 기준 오름차순으로 정렬한 후 출력

	sort(a.begin(), a.end(), [](STRING l, STRING r) {return l.getNum() < r.getNum(); });

	//sort(a.begin(), a.end(), [](STRING l, STRING r) {return l < r; });

	
	/*for (STRING& x : a)
	{
		cout << x << endl;
	}*/

	for (int i{}; i < a.size(); ++i)
	{
		cout << a[i] << endl;
	}

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1506
저장 시간 : 2022-03-31 11:31:42 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 31일 목요일
// 수78목23 (5주 1일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 
//		deque
//		foward_list
//		list
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <array>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] 

int main()
{	

	array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};

	cout << sizeof(a) << endl;		// int[10]이 차지하는 메모리와 같다.

	// 원소를 출력하시오 - 반복자 버전
	//{
	//	for (array<int, 10>::iterator p = a.begin(); p != a.end(); ++p)		//for (auto p = a.begin(); p != a.end(); ++p)
	//	{
	//		cout << *p << " ";
	//	}
	//	cout << endl;
	//}
	//{
	//	// while 사용 버전
	//	auto i = a.cbegin();
	//	while (i != a.cend())
	//	{
	//		cout << *i++ << " ";
	//	}
	//	cout << endl;
	//}
	/*{
		for (auto x : a)
			cout << x << " ";
		cout << endl;
	}*/
	// [문제] a의 원소를 거꾸로 출력하라.

	/*{
		for (auto i = a.rbegin(); i != a.rend(); ++i)
		{
			cout << *i << " ";
		}
		cout << endl;
	}
	{
		for (int i = a.size(); 0 < i; --i)
			cout << a[i - 1] << " ";
		cout << endl;
	}*/

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1046
저장 시간 : 2022-03-31 11:34:11 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 31일 목요일
// 수78목23 (5주 1일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 
//		deque
//		foward_list
//		list
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <array>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] 

int main()
{	

	array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};

	cout << sizeof(a) << endl;		// int[10]이 차지하는 메모리와 같다.

	a.fill(333);

	// 원소를 출력하시오 - 반복자 버전
	{
		for (array<int, 10>::iterator p = a.begin(); p != a.end(); ++p)		//for (auto p = a.begin(); p != a.end(); ++p)
		{
			cout << *p << " ";
		}
		cout << endl;
	}


	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 850
저장 시간 : 2022-03-31 11:34:38 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 31일 목요일
// 수78목23 (5주 1일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 
//		deque
//		foward_list
//		list
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <array>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] 

int main()
{	

	array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};

	cout << sizeof(a) << endl;		// int[10]이 차지하는 메모리와 같다.

	cout << a.max_size() << endl;

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 921
저장 시간 : 2022-03-31 11:49:32 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 31일 목요일
// 수78목23 (5주 1일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 
//		deque
//		foward_list
//		list
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <fstream>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] vector에 "소스.cpp" 파일을 읽어들여서 출력하라.

int main()
{	
	ifstream in("소스.cpp");


	vector<char> v;
	char c;
	while (in >> noskipws >> c)
		v.push_back(c);

	for (char c : v)
		cout << c;
	cout << endl;

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 907
저장 시간 : 2022-04-06 16:09:06 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 06일 요일
// 수78목23 (5주 2일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 
//		deque
//		foward_list
//		list
// 
// 예정 - 중간시험 4.27(수) (8주 2일)
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] 

int main()
{
	관찰 = true;
	
	unique_ptr<STRING> p{ new STRING { "12345" } };
	STRING s{ "12345" };		// 생성위치가 다르다.

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1123
저장 시간 : 2022-04-06 16:23:33 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 06일 요일
// 수78목23 (5주 2일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 
//		deque
//		foward_list
//		list
// 
// 예정 - 중간시험 4.27(수) (8주 2일)
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] 키보드에서 int를 입력받아라.
// 합계와 평균을 화면에 출력하라.

int main()
{
	save("소스.cpp");

	vector<int> iv{};

	int i;

	while (cin >> i)
		iv.push_back(i);

	long long sum{};

	for (auto i = iv.begin(); i != iv.end(); ++i)
	{
		sum += *i;
	}

	cout << "합계 : " << sum << endl << "평균 : " << sum / iv.size() << endl;

}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1007
저장 시간 : 2022-04-06 16:44:29 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 06일 요일
// 수78목23 (5주 2일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 
//		deque
//		foward_list
//		list
// 
// 예정 - 중간시험 4.27(수) (8주 2일)
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] 

int main()
{
	vector v{ 1,2,3 };

	cout << "벡터의 원소 수 : " << v.size() << endl << "원소의 위치 : " << v.data() << endl << "재할당 하지 않고 담을 수 있는 원소의 수(용량) : " << v.capacity() << endl;

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1233
저장 시간 : 2022-04-06 16:59:30 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 06일 요일
// 수78목23 (5주 2일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 
//		deque
//		foward_list
//		list
// 
// 예정 - 중간시험 4.27(수) (8주 2일)
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] 

int main()
{
	save("소스.cpp");

	vector<int> v;
	int i = 0;

	v.reserve(10);			// 10칸 예약

	size_t old_capacity = v.capacity();

	while (true)
	{
		v.push_back(++i);

		if (v.size() -1 == old_capacity)
		{
			cout << "벡터의 원소 수 : " << v.size() << endl << "원소의 위치 : " << v.data() << endl << "재할당 하지 않고 담을 수 있는 원소의 수(용량) : " << v.capacity() << endl << endl;
			old_capacity = v.capacity();
		}

	}
	
	
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 865
저장 시간 : 2022-04-06 17:01:08 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 06일 요일
// 수78목23 (5주 2일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 
//		deque
//		foward_list
//		list
// 
// 예정 - 중간시험 4.27(수) (8주 2일)
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] 

int main()
{
	관찰 = true;

	vector<STRING> v{ "1234567" };

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 865
저장 시간 : 2022-04-06 17:03:11 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 06일 요일
// 수78목23 (5주 2일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 
//		deque
//		foward_list
//		list
// 
// 예정 - 중간시험 4.27(수) (8주 2일)
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] 

int main()
{
	관찰 = true;

	vector<STRING> v{ "1234567" };

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1088
저장 시간 : 2022-04-06 17:10:50 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 06일 요일
// 수78목23 (5주 2일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 
//		deque
//		foward_list
//		list
// 
// 예정 - 중간시험 4.27(수) (8주 2일)
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] 

int main()
{
	관찰 = true;

	vector<STRING> v{ "1234567" };			

	v.push_back("1234567890");

	// 객체 생성 시 임시객체를 생성한 후 vector에서 size() = 1, capacity() = 1, 
	//sizeof(STRING)이 들어갈 메모리를 heap에 확보한 후 new로 만든 임시객체를 복사생성(deep_copy)해 추가한다.

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1128
저장 시간 : 2022-04-07 10:45:50 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 06일 요일
// 수78목23 (5주 2일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 
//		deque
//		foward_list
//		list
// 
// 예정 - 중간시험 4.27(수) (8주 2일)
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] 

int main()
{
	관찰 = true;

	vector<STRING> v;

	v.reserve(10);

	v.emplace_back( "1234567" );

	v.emplace_back("1234567890");

	// 객체 생성 시 임시객체를 생성한 후 vector에서 size() = 1, capacity() = 1, 
	// sizeof(STRING)이 들어갈 메모리를 heap에 확보한 후 new로 만든 임시객체를 복사생성(deep_copy)해 추가한다.

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1239
저장 시간 : 2022-04-13 15:28:53 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일
// 수78목23 (6주 1일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 깊게 알아볼 가치가 있는 컨테이너
//		deque
//		foward_list
//		list
// 
// 예정 - 중간시험 4.27(수) (8주 2일)
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] "소스.cpp"를 읽어 영문자갯수를 세서 다음 형식과 같이 출력
// [a] - 10
int main()
{
	ifstream in{ "소스.cpp" };

	char c;
	int cnt[26]{};

	while (in >> c)
	{
		c = tolower(c);

		if (isalpha(c) != 0)
		{
			for (int i = 0; i < 26; ++i)
			{
				if (c == i + 'a')
				{
					cnt[i]++;
				}
			}
		}
	}

	for (int i = 0; i < 26; ++i)
	{
		cout << "[" << (char)(i + 'a') << "] - " << cnt[i] << endl;
	}

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1453
저장 시간 : 2022-04-13 15:44:57 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일
// 수78목23 (6주 2일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 깊게 알아볼 가치가 있는 컨테이너
//		deque
//		foward_list
//		list
// 
// 예정 - 중간시험 4.20(수) (7주 2일)
// 시험시간 70분 1745~
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] "소스.cpp"를 읽어 영문자갯수를 세서 다음 형식과 같이 출력
// [a] - 10

int main()
{
	ifstream in{ "소스.cpp" };

	char c;
	int cnt[26]{};
	array<int, 26> arr{};

	// 내 풀이
	{
		/*while (in >> c)
		{
			c = tolower(c);

			if (isalpha(c) != 0)
			{
				for (int i = 0; i < 26; ++i)
				{
					if (c == i + 'a')
					{
						cnt[i]++;
					}
				}
			}
		}*/
	}
	
	//교수님 풀이
	
	while (in >> c)
		if (isalpha(c))
			arr[tolower(c) - 'a']++;

	for (int i = 0; i < arr.size(); ++i)
	{
		cout << "[" << static_cast<char>(i + 'a') << "] - " << arr[i] << endl;
	}

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1986
저장 시간 : 2022-04-13 16:47:58 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일
// 수78목23 (6주 2일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 깊게 알아볼 가치가 있는 컨테이너
//							- 원소를 마지막 위치에 추가하는 데 특화되어 있다 (O(1))
//		deque
//		foward_list
//		list
// 
// 예정 - 중간시험 4.20(수) (7주 2일)
// 시험시간 70분 1745~
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <vector>
#include <deque>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// deque는 원소를 같은 공간에 있는것 "처럼" 관리한다. push_back, push_front 동작이 매우 간편함. 하지만
// 덱은 원소를 n개씩 담는 리스트이다. 메모리가 붙어있는 듯이 보이지만 데이터를 "블럭"(데이터가 n개씩 모인) 단위로 관리.
// 벡터는 access가 O(1) , 리스트는 임의의 위치 삭제가 O(1) access는 O(n). 이 둘의 중간이 덱.
// 마치 연속된 메모리 인것처럼 access도 상수시간이고(상수시간인 척 하는거지만 상수시간임.), 리스트처럼 임의의 위치 및 삭제도 상수시간이다.
// "실제 그렇지는 않다"는 것에 주의할것.
// 벡터는 메모리 할당구역 이상의 인수를 넣을 때 통째로 들어서 새로운 공간으로 이사간다.
// 덱의 핵심 특징은 한번 확보한 메모리 공간이 다른 곳으로 이동하지는 않는다.
// 덱은 삽입하거나 삭제하더라도 절대 원소를 가리키던 포인터나 레퍼런스가 무효화되지 않는다.
// 덱은 연속적으로 저장되지 않았으므로 주의.
// 

// [문제] vector는 연속인데, deque는 연속이 아니라고?
// 주소를 확인해보면 됨.

int main()
{
	deque<int> d{ 1,2,3,4,5 };
	for (int i = 0; i < d.size(); ++i)
		cout << d[i] << endl;
	cout << sizeof(d) << endl; // 벡터 : 24, 덱 : 40. 왜? 

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 2023
저장 시간 : 2022-04-13 16:51:52 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일
// 수78목23 (6주 2일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 깊게 알아볼 가치가 있는 컨테이너
//							- 원소를 마지막 위치에 추가하는 데 특화되어 있다 (O(1))
//		deque
//		foward_list
//		list
// 
// 예정 - 중간시험 4.20(수) (7주 2일)
// 시험시간 70분 1745~
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <vector>
#include <deque>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// deque는 원소를 같은 공간에 있는것 "처럼" 관리한다. push_back, push_front 동작이 매우 간편함. 하지만
// 덱은 원소를 n개씩 담는 리스트이다. 메모리가 붙어있는 듯이 보이지만 데이터를 "블럭"(데이터가 n개씩 모인) 단위로 관리.
// 벡터는 access가 O(1) , 리스트는 임의의 위치 삭제가 O(1) access는 O(n). 이 둘의 중간이 덱.
// 마치 연속된 메모리 인것처럼 access도 상수시간이고(상수시간인 척 하는거지만 상수시간임.), 리스트처럼 임의의 위치 및 삭제도 상수시간이다.
// "실제 그렇지는 않다"는 것에 주의할것.
// 벡터는 메모리 할당구역 이상의 인수를 넣을 때 통째로 들어서 새로운 공간으로 이사간다.
// 덱의 핵심 특징은 한번 확보한 메모리 공간이 다른 곳으로 이동하지는 않는다.
// 덱은 삽입하거나 삭제하더라도 절대 원소를 가리키던 포인터나 레퍼런스가 무효화되지 않는다.
// 덱은 연속적으로 저장되지 않았으므로 주의.
// 

// [문제] vector는 연속인데, deque는 연속이 아니라고?
// 주소를 확인해보면 됨.

class Test
{
	char c[1000];
public:
	void show() const {
		cout << (long long)this << endl;
	}
};

int main()
{
	vector<Test> v(10);

	for (int i = 0; i < v.size(); ++i)
		v[i].show();

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 2855
저장 시간 : 2022-04-13 17:00:19 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일
// 수78목23 (6주 2일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 깊게 알아볼 가치가 있는 컨테이너
//							- 원소를 마지막 위치에 추가하는 데 특화되어 있다 (O(1))
//		deque				- contigous 컨테이너가 아님.
//		foward_list
//		list
// 
// 예정 - 중간시험 4.20(수) (7주 2일)
// 시험시간 70분 1745~
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <vector>
#include <deque>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// deque는 원소를 같은 공간에 있는것 "처럼" 관리한다. push_back, push_front 동작이 매우 간편함. 하지만
// 덱은 원소를 n개씩 담는 리스트이다. 메모리가 붙어있는 듯이 보이지만 데이터를 "블럭"(데이터가 n개씩 모인) 단위로 관리.
// 벡터는 access가 O(1) , 리스트는 임의의 위치 삭제가 O(1) access는 O(n). 이 둘의 중간이 덱.
// 마치 연속된 메모리 인것처럼 access도 상수시간이고(상수시간인 척 하는거지만 상수시간임.), 리스트처럼 임의의 위치 및 삭제도 상수시간이다.
// "실제 그렇지는 않다"는 것에 주의할것.
// 벡터는 메모리 할당구역 이상의 인수를 넣을 때 통째로 들어서 새로운 공간으로 이사간다.
// 덱의 핵심 특징은 한번 확보한 메모리 공간이 다른 곳으로 이동하지는 않는다.
// 덱은 삽입하거나 삭제하더라도 절대 원소를 가리키던 포인터나 레퍼런스가 무효화되지 않는다.
// 덱은 연속적으로 저장되지 않았으므로 주의.
// 

// 벡터는 기존 크기보다 인수가 늘어날 시 기존 메모리를 반환하고 새로운 메모리를 재할당함.
// 처음부터 끝까지 하나도 빈틈없는 메모리를 하나 떼서 줘야함. 하지만 시스템이 메모리를 그렇게 깨끗하게 관리하지 않음. 벡터의 최대 메모리에 제한이 있음.
// 덱은 띄엄띄엄 담을 수 있으므로 덱이 더 유리한 경우가 있음.
// 

// [문제] vector는 연속인데, deque는 연속이 아니라고?
// 주소를 확인해보면 됨.

// [문제2] vector보다 deque이 원소를 더 많이 담을 수 있다고?
// 

class Test
{
	char c[1024];
public:
	void show() const {
		cout << (long long)this << endl;
	}
};

int main()
{
	deque<Test> v(10);

	v.push_front(Test{});

	for (int i = 0; i < v.size(); ++i)
		v[i].show();

	save("소스.cpp");
}

/*
2389308997664
2389308998664
2389308999664
2389309000664
2389309001664
2389309002664
2389309003664
2389309004664
2389309005664
2389309006664
*/

// 1000씩 바뀜

// push_front 동작
/*
2395353330000
2395353319920
2395353320928
2395353321936
2395353322944
2395353323952
2395353324960
2395353325968
2395353326976
2395353327984
2395353328992
*/

// 1000씩 바뀜?

===================================================================
파일 이름 : 소스.cpp
파일크기 : 2808
저장 시간 : 2022-04-13 17:02:23 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일
// 수78목23 (6주 2일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 깊게 알아볼 가치가 있는 컨테이너
//							- 원소를 마지막 위치에 추가하는 데 특화되어 있다 (O(1))
//		deque				- contigous 컨테이너가 아님.
//		foward_list
//		list
// 
// 예정 - 중간시험 4.20(수) (7주 2일)
// 시험시간 70분 1745~
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <vector>
#include <deque>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// deque는 원소를 같은 공간에 있는것 "처럼" 관리한다. push_back, push_front 동작이 매우 간편함. 하지만
// 덱은 원소를 n개씩 담는 리스트이다. 메모리가 붙어있는 듯이 보이지만 데이터를 "블럭"(데이터가 n개씩 모인) 단위로 관리.
// 벡터는 access가 O(1) , 리스트는 임의의 위치 삭제가 O(1) access는 O(n). 이 둘의 중간이 덱.
// 마치 연속된 메모리 인것처럼 access도 상수시간이고(상수시간인 척 하는거지만 상수시간임.), 리스트처럼 임의의 위치 및 삭제도 상수시간이다.
// "실제 그렇지는 않다"는 것에 주의할것.
// 벡터는 메모리 할당구역 이상의 인수를 넣을 때 통째로 들어서 새로운 공간으로 이사간다.
// 덱의 핵심 특징은 한번 확보한 메모리 공간이 다른 곳으로 이동하지는 않는다.
// 덱은 삽입하거나 삭제하더라도 절대 원소를 가리키던 포인터나 레퍼런스가 무효화되지 않는다.
// 덱은 연속적으로 저장되지 않았으므로 주의.
// 

// 벡터는 기존 크기보다 인수가 늘어날 시 기존 메모리를 반환하고 새로운 메모리를 재할당함.
// 처음부터 끝까지 하나도 빈틈없는 메모리를 하나 떼서 줘야함. 하지만 시스템이 메모리를 그렇게 깨끗하게 관리하지 않음. 벡터의 최대 메모리에 제한이 있음.
// 덱은 띄엄띄엄 담을 수 있으므로 덱이 더 유리한 경우가 있음.
// 

// [문제] vector는 연속인데, deque는 연속이 아니라고?
// 주소를 확인해보면 됨.

// [문제2] vector보다 deque이 원소를 더 많이 담을 수 있다고?
// 

class Test
{
	char c[1024];
public:
	void show() const {
		cout << (long long)this << endl;
	}
};

int main()
{
	save("소스.cpp");

	vector<int> v;

	while (true)
		v.push_back(1);

}

/*
2389308997664
2389308998664
2389308999664
2389309000664
2389309001664
2389309002664
2389309003664
2389309004664
2389309005664
2389309006664
*/

// 1000씩 바뀜

// push_front 동작
/*
2395353330000
2395353319920
2395353320928
2395353321936
2395353322944
2395353323952
2395353324960
2395353325968
2395353326976
2395353327984
2395353328992
*/

// 1000씩 바뀜?

===================================================================
파일 이름 : 소스.cpp
파일크기 : 2977
저장 시간 : 2022-04-13 17:11:15 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일
// 수78목23 (6주 2일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 깊게 알아볼 가치가 있는 컨테이너
//							- 원소를 마지막 위치에 추가하는 데 특화되어 있다 (O(1))
//		deque				- contigous 컨테이너가 아님.
//		foward_list
//		list
// 
// 예정 - 중간시험 4.20(수) (7주 2일)
// 시험시간 70분 1745~
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <vector>
#include <deque>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// deque는 원소를 같은 공간에 있는것 "처럼" 관리한다. push_back, push_front 동작이 매우 간편함. 하지만
// 덱은 원소를 n개씩 담는 리스트이다. 메모리가 붙어있는 듯이 보이지만 데이터를 "블럭"(데이터가 n개씩 모인) 단위로 관리.
// 벡터는 access가 O(1) , 리스트는 임의의 위치 삭제가 O(1) access는 O(n). 이 둘의 중간이 덱.
// 마치 연속된 메모리 인것처럼 access도 상수시간이고(상수시간인 척 하는거지만 상수시간임.), 리스트처럼 임의의 위치 및 삭제도 상수시간이다.
// "실제 그렇지는 않다"는 것에 주의할것.
// 벡터는 메모리 할당구역 이상의 인수를 넣을 때 통째로 들어서 새로운 공간으로 이사간다.
// 덱의 핵심 특징은 한번 확보한 메모리 공간이 다른 곳으로 이동하지는 않는다.
// 덱은 삽입하거나 삭제하더라도 절대 원소를 가리키던 포인터나 레퍼런스가 무효화되지 않는다.
// 덱은 연속적으로 저장되지 않았으므로 주의.
// 

// 벡터는 기존 크기보다 인수가 늘어날 시 기존 메모리를 반환하고 새로운 메모리를 재할당함.
// 처음부터 끝까지 하나도 빈틈없는 메모리를 하나 떼서 줘야함. 하지만 시스템이 메모리를 그렇게 깨끗하게 관리하지 않음. 벡터의 최대 메모리에 제한이 있음.
// 덱은 띄엄띄엄 담을 수 있으므로 덱이 더 유리한 경우가 있음.
// 

// [문제2] vector보다 deque이 원소를 더 많이 담을 수 있다고?
// 

class Test
{
	char c[1024];
public:
	void show() const {
		cout << (long long)this << endl;
	}
};

int main()
{
	save("소스.cpp");

	/*vector<int> v;

	while (true)
	{
		try 
		{
			v.push_back(1);
		}
		catch (exception& e)
		{
			cout << "벡터가 저장한 원소 갯수 : " << v.size() << endl;
			return 0;
		}
	}*/
	// vector<Test> : 466609
	// deque<Test> : 1982338
	// vector<int> : 136216567
	// deque<int> : 268435452

}

/*
2389308997664
2389308998664
2389308999664
2389309000664
2389309001664
2389309002664
2389309003664
2389309004664
2389309005664
2389309006664
*/

// 1000씩 바뀜

// push_front 동작
/*
2395353330000
2395353319920
2395353320928
2395353321936
2395353322944
2395353323952
2395353324960
2395353325968
2395353326976
2395353327984
2395353328992
*/

// 1000씩 바뀜?

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1355
저장 시간 : 2022-04-14 11:51:16 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일
// 수78목23 (6주 2일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 깊게 알아볼 가치가 있는 컨테이너
//							- 원소를 마지막 위치에 추가하는 데 특화되어 있다 (O(1))
//		deque				- contigous 컨테이너가 아님.
//		foward_list
//		list
// 
// 예정 - 중간시험 4.20(수) (7주 2일)
// 시험시간 70분 1745~
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include <fstream>
#include <string>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] "소스.cpp"의 단어(string)를 deque에 읽어오시오.
// 이것을 오름차순 정렬하시오.
// 결과를 출력하시오.
// 

int main()
{
	ifstream in{ "소스.cpp" };

	string s;

	deque<string> sd;

	while (in >> s)
	{
		sd.push_back(s);
	}

	sort(sd.begin(), sd.end(), [](string l, string r) {return l < r; });

	for (const string& s : sd)
		cout << s << "\t";

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1567
저장 시간 : 2022-04-14 11:52:37 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일
// 수78목23 (6주 2일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 깊게 알아볼 가치가 있는 컨테이너
//							- 원소를 마지막 위치에 추가하는 데 특화되어 있다 (O(1))
//		deque				- contigous 컨테이너가 아님.
//		foward_list
//		list
// 
// 예정 - 중간시험 4.20(수) (7주 2일)
// 시험시간 70분 1745~
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include <fstream>
#include <string>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] "컨테이너.txt"의 단어(string)를 deque에 읽어오시오.
// deque에 저장된 각 단어를 오름차순으로 정렬하시오.
// deque의 단어를 길이 오름차순 정렬하시오.
// 결과를 출력하시오.
// 

int main()
{
	ifstream in{ "컨테이너.txt" };

	// 덱에 읽어온다
	deque<string> d{ istream_iterator<string>{in},{} };

	// space란 단어는 몇 번째 단어인가?
	// 참고로 library는 3번째 단어이다.
	
	// 값 == 값으로 찾을 때에는 find함수가 더 유리함.

	auto p = find(d.begin(), d.end(), "library");

	cout << "단어" << *p << "는 : " << p - d.begin() + 1 << "번 째 단어입니다." << endl;

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1397
저장 시간 : 2022-04-14 11:56:55 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일
// 수78목23 (6주 2일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 깊게 알아볼 가치가 있는 컨테이너
//							- 원소를 마지막 위치에 추가하는 데 특화되어 있다 (O(1))
//		deque				- contigous 컨테이너가 아님.
//		foward_list
//		list
// 
// 예정 - 중간시험 4.20(수) (7주 2일)
// 시험시간 70분 1745~
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <string>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] "컨테이너.txt"의 단어(string)를 deque에 읽어오시오.
// deque에 저장된 각 단어를 오름차순으로 정렬하시오.
// deque의 단어를 길이 오름차순 정렬하시오.
// 결과를 출력하시오.
// 

int main()
{
	ifstream in{ "컨테이너.txt" };

	list<string> l;

	string s;

	while (in >> s)
	{
		l.push_back(s);
	}

	l.sort();

	for (auto i = l.begin(); i != next(l.begin(), 10); ++i)
		cout << *i << endl;

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1453
저장 시간 : 2022-04-14 11:57:26 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일
// 수78목23 (6주 2일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 깊게 알아볼 가치가 있는 컨테이너
//							- 원소를 마지막 위치에 추가하는 데 특화되어 있다 (O(1))
//		deque				- contigous 컨테이너가 아님.
//		foward_list
//		list
// 
// 예정 - 중간시험 4.20(수) (7주 2일)
// 시험시간 70분 1745~
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <string>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] "컨테이너.txt"의 단어(string)를 deque에 읽어오시오.
// deque에 저장된 각 단어를 오름차순으로 정렬하시오.
// deque의 단어를 길이 오름차순 정렬하시오.
// 결과를 출력하시오.
// 

int main()
{
	ifstream in{ "컨테이너.txt" };

	list<string> l;

	string s;

	while (in >> s)
	{
		l.push_back(s);
	}

	l.sort();

	for (const string& s : l)
		cout << s << endl;

	/*for (auto i = l.begin(); i != next(l.begin(), 10); ++i)
		cout << *i << endl;*/

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1403
저장 시간 : 2022-04-14 11:57:42 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일
// 수78목23 (6주 2일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 깊게 알아볼 가치가 있는 컨테이너
//							- 원소를 마지막 위치에 추가하는 데 특화되어 있다 (O(1))
//		deque				- contigous 컨테이너가 아님.
//		foward_list
//		list
// 
// 예정 - 중간시험 4.20(수) (7주 2일)
// 시험시간 70분 1745~
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <string>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] "컨테이너.txt"의 단어(string)를 deque에 읽어오시오.
// deque에 저장된 각 단어를 오름차순으로 정렬하시오.
// deque의 단어를 길이 오름차순 정렬하시오.
// 결과를 출력하시오.
// 

int main()
{
	ifstream in{ "컨테이너.txt" };

	list<string> l;

	string s;

	while (in >> s)
	{
		l.push_back(s);
	}

	l.sort();



	for (auto i = l.rbegin(); i != next(l.rbegin(), 10); ++i)
		cout << *i << endl;

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1401
저장 시간 : 2022-04-14 12:00:24 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일
// 수78목23 (6주 2일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 깊게 알아볼 가치가 있는 컨테이너
//							- 원소를 마지막 위치에 추가하는 데 특화되어 있다 (O(1))
//		deque				- contigous 컨테이너가 아님.
//		foward_list
//		list
// 
// 예정 - 중간시험 4.20(수) (7주 2일)
// 시험시간 70분 1745~
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <string>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] "컨테이너.txt"의 단어(string)를 deque에 읽어오시오.
// deque에 저장된 각 단어를 오름차순으로 정렬하시오.
// deque의 단어를 길이 오름차순 정렬하시오.
// 결과를 출력하시오.
// 

int main()
{
	ifstream in{ "컨테이너.txt" };

	list<string> l;

	string s;

	while (in >> s)
	{
		l.push_back(s);
	}

	l.sort();

	for (auto i = l.crbegin(); i != next(l.crbegin(), 10); ++i)
		cout << *i << endl;

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1796
저장 시간 : 2022-04-14 12:21:25 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일
// 수78목23 (6주 2일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 깊게 알아볼 가치가 있는 컨테이너
//							- 원소를 마지막 위치에 추가하는 데 특화되어 있다 (O(1))
//		deque				- contigous 컨테이너가 아님.
//		foward_list
//		list
// 
// 예정 - 중간시험 4.20(수) (7주 2일)
// 시험시간 70분 1745~
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <string>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] "컨테이너.txt"의 단어(string)를 list에 읽어오시오.
// 오름차순 정렬하시오. 
// space라는 단어는 몇 번째 단어인가?
// 결과를 출력하시오.
// 

// 덱은 random access가 O(1)동작, 반복자 무효화 없음이 핵심 특징
//

int main()
{
	ifstream in{ "컨테이너.txt" };

	list<string> l;


	string s;

	while (in >> s)
	{
		l.push_back(s);
	}

	auto p = find(l.begin(), l.end(), "space");
	if (p == l.end())
		cout << "그런거 없어요" << endl;
	else
	{
		cout << *p << "는 " << distance(l.begin(), p) + 1 << "번 째 단어입니다." << endl;
		/*int step{};
		auto b = l.begin();
		cout << *p << "는 ";
		while (true)
		{
			if (p == b){
				cout << step + 1 << "번 째 단어입니다." << endl;
				break;
			}
			else
			{
				step++;
				b++;
			}
		}distance의 기능과 같음
		*/
	}


	save("소스.cpp");
}

// wkdgudxor

#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <fstream>
#include <filesystem>

using namespace std;

class Player
{
public:
    string name; // 이름
    int id; // 아이디

    friend ostream& operator<<(ostream&, const Player&);
    friend istream& operator>>(istream& is, Player& p);
    friend bool operator==(int i, Player p);

public:
    Player() : id{}
    {

    }
    ~Player()
    {

    }

    int get_id() const
    {
        return id;
    }

    string get_name() const
    {
        return name;
    }

    void set_name_upper()
    {
        name[0] = toupper(name[0]);
    }

    void write(ostream& os)
    {
        os.write((char*)this, sizeof(Player));
    }

    bool read(istream& is)
    {
        is.read((char*)this, sizeof(Player));

        return !is.eof();
    }
};

bool operator==(int i, Player p)
{
    return p.id == i;
}

ostream& operator<<(ostream& os, const Player& p)
{
    os << "이름 : " << p.name << ", ";
    os << "아이디 : " << p.id << endl;
    return os;
}

istream& operator>>(istream& is, Player& p)
{
    is >> p.name;
    is >> p.id;
    return is;
}

int main()
{
    string fileName{ "중간시험.dat"s };

    ifstream in{ fileName, ios::binary };

    if (!in)
    {
        cout << fileName << " : 파일을 열 수 없습니다." << endl;
        exit(0);
    }

    size_t fileSize = filesystem::file_size(fileName);
    cout << fileName << "의 크기는 : " << fileSize << endl;

    vector<Player> v{ istream_iterator<Player>{in},{} };

    cout << v.size() << endl;

    // 2번
    cout << *v.crbegin() << endl;

    // 3번
    for (Player& p : v)
    {
        p.set_name_upper();
    }

    auto p = find_if(v.begin(), v.end(), [](Player& p) {
        return p.get_name() == "Stlcontainer"s; 
        });

    if (p == v.end())
    {
        cout << "없습니다." << endl;
    }
    else
    {
        cout << *p;
        cout << distance(v.begin(), p) + 1 << endl << endl;
    }

    cout << "id를 검색합니다" << endl;

    while(true)
    {
        int id;
        cout << "찾으려는 id를 입력하세요 : ";
        cin >> id;

        vector<Player> sv;

        if (id < 1 || 10000 < id)
        {
            cout << "유효한 id는 [1,10000] 입니다." << endl << endl;
            continue;
        }

        int cnt = count_if(v.begin(), v.end(), [&sv,id](Player& p) {
            if (p == id)
            {
                sv.push_back(p);
                return true;
            }
            else
                return false;
            });

        sort(sv.begin(), sv.end(), [](const Player& l, const Player& r) {
            return l.get_name().length() < r.get_name().length();
            });

        cout << "id가 " << id << "객체의 수 - " << cnt << endl;
        for (const Player& p : sv)
            cout << p;
        cout << endl;
    }

}

// wkdgudxor2

#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <fstream>
#include <filesystem>

using namespace std;

class Test
{
public:
    string name; // 이름
    int id; // 아이디

    friend ostream& operator<<(ostream&, const Test&);
    friend istream& operator>>(istream& is, Test& p);
    friend bool operator==(int i, Test p);

public:
    Test() : id{}
    {

    }
    ~Test()
    {

    }

    int get_id() const
    {
        return id;
    }

    string get_name() const
    {
        return name;
    }

    void set_name_upper()
    {
        name[0] = toupper(name[0]);
    }

    void write(ostream& os)
    {
        os.write((char*)this, sizeof(Test));
    }

    bool read(istream& is)
    {
        is.read((char*)this, sizeof(Test));

        return !is.eof();
    }

    void show() const
    {
        cout << name << ", " << id << endl;
    }
};

bool operator==(int i, Test p)
{
    return p.id == i;
}

ostream& operator<<(ostream& os, const Test& p)
{
    os << "이름 : " << p.name << ", ";
    os << "아이디 : " << p.id << endl;
    return os;
}

istream& operator>>(istream& is, Test& p)
{
    is >> p.name;
    is >> p.id;
    return is;
}


string file1{ "시험1.dat" };
string file2{ "시험2.dat" };

int main()
{
	ifstream in1{ file1, ios::binary };
	ifstream in2{ file2, ios::binary };

	if (!in1 || !in2)
	{
		cout << "파일을 열 수 없습니다" << endl;
		return 0;
	}

    size_t fileSize = filesystem::file_size(file1);
    cout << file1 << "의 크기는 : " << fileSize << endl;

    Test t{};
    vector<Test> v1;
    vector<Test> v2;

    while (in1)
    {
        in1.read((char*)&t, sizeof(Test));
        v1.push_back(t);
    }

    cout << v1.size() << endl;

    while (in2)
    {
        in2.read((char*)&t, sizeof(Test));
        v2.push_back(t);
    }

    cout << v2.size() << endl;
    v1[10000].show();
    v2[10000].show();

}

// wkdgudxor3

#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <fstream>
#include <filesystem>

using namespace std;

class Player
{
public:
    string name; // 이름
    int id; // 아이디

    friend ostream& operator<<(ostream&, const Player&);
    friend istream& operator>>(istream& is, Player& p);
    friend bool operator==(int i, Player p);

public:
    Player() : id{}
    {

    }
    ~Player()
    {

    }

    int get_id() const
    {
        return id;
    }

    string get_name() const
    {
        return name;
    }

    void set_name_upper()
    {
        *name.begin() = toupper(*name.begin());
    }

    void write(ostream& os)
    {
        os.write((char*)this, sizeof(Player));
    }

    bool read(istream& is)
    {
        is.read((char*)this, sizeof(Player));

        return !is.eof();
    }
};

bool operator==(int i, Player p)
{
    return p.id == i;
}

ostream& operator<<(ostream& os, const Player& p)
{
    os << "이름 : " << p.name << ", ";
    os << "아이디 : " << p.id << endl;
    return os;
}

istream& operator>>(istream& is, Player& p)
{
    is >> p.name;
    is >> p.id;
    return is;
}

int main()
{
    string fileName{ "중간시험.dat"s };

    ifstream in{ fileName, ios::binary };

    if (!in)
    {
        cout << fileName << " : 파일을 열 수 없습니다." << endl;
        exit(0);
    }

    size_t fileSize = filesystem::file_size(fileName);
    cout << fileName << "의 크기는 : " << fileSize << endl;

    cout << "fileSize / sizeof(Player) : " << fileSize / sizeof(Player) << endl;

    Player pp{};
    vector<Player> v;

    while (in)
    {
        in.read((char*)&pp, sizeof(Player));
        v.push_back(pp);
    }
    cout << v.size() << endl;

    cout << *v.crbegin() << endl;

    /*for (Player& p : v)
    {
        p.set_name_upper();
    }*/

    auto p = find_if(v.begin(), v.end(), [](Player& p) {
        return p.get_name() == "standardlibrary"s;
        });

    if (p == v.end())
    {
        cout << "없습니다." << endl;
    }
    else
    {
        cout << *p;
        cout << distance(v.begin(), p) + 1 << endl << endl;
    }

    cout << "id를 검색합니다" << endl;

    while (true)
    {
        int id;
        cout << "찾으려는 id를 입력하세요 : ";
        cin >> id;

        vector<Player> sv;

        if (id < 1 || 10000 < id)
        {
            cout << "유효한 id는 [1,10000] 입니다." << endl << endl;
            continue;
        }

        int cnt = count_if(v.begin(), v.end(), [&sv, id](Player& p) {
            if (p == id)
            {
                sv.push_back(p);
                return true;
            }
            else
                return false;
            });

        /*sort(sv.begin(), sv.end(), [](const Player& l, const Player& r) {
            return l.get_name().length() < r.get_name().length();
            });*/

        cout << "id가 " << id << "객체의 수 : " << cnt << endl;
        for (const Player& p : sv)
            cout << p;
        cout << endl;
    }
}

// wkdgudxor4

#include <iostream>
#include <algorithm>
#include <vector>
#include <set>
#include <map>
#include <string>
#include <fstream>
#include <filesystem>

using namespace std;

int main()
{
	ifstream in{ "셜록홈즈의 모험.txt" };

	string s;

	vector<string> v{ istream_iterator<string>{ in }, {} };
	cout << v.size() << endl;

	cout << *max_element(v.begin(), v.end(), [](const string& a, const string& b) {
		return a.size() < b.size();
		}) << endl;

	for (string& s : v) {
		for (char& c : s)
			c = tolower(c);
	}
	set<string> ss{ v.begin(), v.end() };
	cout << ss.size() << endl;

	map<string, int> m;

	for (string const& x : v) {
		string a = x;
		transform(a.begin(), a.end(), a.begin(), tolower);
		m[a]++;
	}

	cout << "단어와 개수 쌍의 개수 - " << m.size() << endl;
	vector< pair<string, int>> siv;
	for (auto [단어, 개수] : m) {
		siv.emplace_back(단어, 개수);
	}

	sort(siv.begin(), siv.end(),
		[](const pair<string, int>& a, const pair<string, int>& b) {
			return a.second > b.second;
		});

	for (int i = 0; i < 5; ++i) {
		cout << siv[i].first << " - " << siv[i].second << endl;
	}

	ofstream out{ "e없는 단어.txt" };

	vector<string> noE;
	for (const string& s : v) {
		if (s.find('e') == string::npos) {
			noE.push_back(s);
		}
	}

	cout << "e없는 단어의 수 - " << noE.size() << endl;

	copy(noE.begin(), noE.end(), ostream_iterator<string>(out, " "));

}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1081
저장 시간 : 2022-04-21 11:34:56 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일
// 수78목23 (6주 2일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 깊게 알아볼 가치가 있는 컨테이너
//							- 원소를 마지막 위치에 추가하는 데 특화되어 있다 (O(1))
//		deque				- contigous 컨테이너가 아님.
// 
//		foward_list			- single linked list
//		list				- 임의의 위치에서 삽입과 삭제가 O(1)
// 
// 예정 - 중간시험 4.20(수) (7주 2일)
// 시험시간 70분 1745~
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <string>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] 

int main()
{
	


	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1507
저장 시간 : 2022-05-04 15:37:18 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일
// 수78목23 (6주 2일)
// 
// 컨테이너					- 다른 객체를 저장하는 객체
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// 반복자					- 포인터를 추상화한 것
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

template <class Iter, class Val>
Iter my_find(Iter b, Iter e, Val v)
{
	while (b != e) {
		if (*b == v)
			return b;
		++b;
	}
	return e;
}

template<class Iter>
void show(Iter)
{
	cout << "반복자 타입 : " << typeid(Iter).name() << endl;
	//cout << "반복자의 종류 : " << typename(iterator_traits<Iter>::iterator_category()).name() << endl;
}

// [문제]
// 반복자의 종류(category) 를 구분하고 알아본다.
// 반복자를 인수로 받는 함수를 만들어 어떤 종류의 반복자인지 출력하도록 하자.
//

int main()
{
	save("소스.cpp");
	save("STRING.h");
	save("STRING.cpp");

	STRING s;

	cin >> s;

	// [문제] s에 어떤 문자가 몇 번째인지 출력하자.

	while (true) {
		cout << "찾으려는 문자는? ";
		char c;
		cin >> c;

		auto p = my_find(s.begin(), s.end(), c);
		if (p != s.end()) {
			cout << distance(s.begin(), p) + 1 << "번째 문자입니다" << endl;
		}
		else
			cout << c << "는 없습니다" << endl;
	}
	//save("소스.cpp");
}

===================================================================
파일 이름 : STRING.h
파일크기 : 3170
저장 시간 : 2022-05-04 15:37:18 GMT+9
//----------------------------------------------------------------------------------------------
// STRING.cpp - 자원을 관리하는 STL 관찰용 클래스
// 
// 2022.3.20
//

#pragma once

#include <iostream>

class STRING_iterator {
	// 2022. 4. 28
public:	// 표준 반복자라면 이 다섯가지 타입을 제공해야 한다.
	using iterator_category = std::random_access_iterator_tag;
	using value_type = char;
	using difference_type = ptrdiff_t;
	using pointer = char*;
	using reference = char&;

private:
	char* p;

public:
	STRING_iterator(char* p) : p{ p } {	}

	char& operator*() const {
		return *p;
	};

	STRING_iterator& operator++() {
		++p;
		return *this;
	};

	// 2022. 4. 27 sort가 요구하는 - 연산
	difference_type operator-(const STRING_iterator& rhs) const {
		return p - rhs.p;
	}

	// 2022. 4. 28 sort가 요구하는 -- 연산
	STRING_iterator& operator--() {
		--p;
		return *this;
	}

	STRING_iterator operator+(difference_type d) const {
		return STRING_iterator{ p + d };
	}

	STRING_iterator operator-(difference_type d) const {
		return STRING_iterator{ p - d };
	}



	// <, >, <=, >=, ==, != 
	// 관계연산자를 자동으로 생성하는 우주선 연산자를 사용한다.
	// spaceship operator(three-way comparison operator)

	auto operator<=>(const STRING_iterator& rhs) const = default;

	// 강순서(strong order), 약순서(weak), 부분순서(partial)
	//bool operator!=( const STRING_iterator& rhs ) const {
	//	std::cout << "이게 우선 사용" << "\n";
	//	return p != rhs.p;
	//}
};

class STRING_reverse_iterator {
	char* p;

public:
	STRING_reverse_iterator(char* p) : p{ p } { }

	char& operator*() const {
		return *(p - 1);
	};

	STRING_reverse_iterator& operator++() {
		--p;
		return *this;
	};

	// <, >, <=, >=, ==, != 
	// 관계연산자를 자동으로 생성하는 우주선 연산자를 사용한다.
	// spaceship operator(three-way comparison operator)

	auto operator<=>(const STRING_reverse_iterator& rhs) const = default;
};

class STRING {
	// 페딩 4바이트 속도를 위해 비워둠
	int id;								// 생성 시 부여
	size_t num;							// 확보한 자원의 수
	char* p;							// 확보한 자원의 위치
	static int cid;						// 객체가 생성될 때마다 1 증가

public:
	// 2022. 4. 27
	using iterator = STRING_iterator;
	using reverse_iterator = STRING_reverse_iterator;
public:
	STRING();
	STRING(const char*);
	~STRING();

	STRING(const STRING&);

	STRING operator+(const STRING&) const;

	bool operator<(const STRING&) const;

	STRING operator=(const STRING&);

	bool operator==(const STRING&);

	STRING(STRING&& other)noexcept;

	STRING& operator=(STRING&& other)noexcept;

	void print(const char*);

	size_t getNum();

	// 2022.04.21 begin(), end() 코딩
	iterator begin() const {
		return iterator{ p };
	}

	iterator end() const {
		return iterator{ p + num };
	}

	reverse_iterator rbegin() const {
		return reverse_iterator{ p + num };
	}

	reverse_iterator rend() const {
		return reverse_iterator{ p };
	}

private:
	friend std::ostream& operator<<(std::ostream&, const STRING&);
	// 2022. 4. 28 추가
	friend std::istream& operator>>(std::istream&, STRING&);
};



===================================================================
파일 이름 : STRING.cpp
파일크기 : 2523
저장 시간 : 2022-05-04 15:37:18 GMT+9
//----------------------------------------------------------------------------------------------
// STRING.cpp - 자원을 관리하는 STL 관찰용 클래스
// 
// 2022.3.20
//

#pragma once
#include <iostream>
#include "STRING.h"

bool 관찰{ false };

STRING::STRING() : num{}, p{}, id{ ++cid }
{
	if (관찰)
	{
		print("디폴트");
	}
};
STRING::STRING(const char* s) : num{ strlen(s) }, id{ ++cid }
{
	p = new char[num];

	memcpy(p, s, num);

	if (관찰)
	{
		print("생성자(*)");
	}
};
STRING::~STRING() {
	// 관찰메시지를 켜면 출력한다.
	//std::cout << "dtor [" << id << "] " << this << std::endl;

	if (관찰)
	{
		print("소멸자");
	}

	delete[] p;
}

STRING::STRING(const STRING& other) : num{ other.num }, id{ ++cid }
{
	p = new char[other.num];
	memcpy(p, other.p, num);
	if (관찰)
	{
		print("복사생성");
	}
}

STRING::STRING(STRING&& other) noexcept : id{ ++cid }, num { other.num }
{
	p = other.p;

	other.p = nullptr;
	other.num = 0;

	if (관찰)
	{
		print("이동생성");
	}
}

STRING STRING::operator+(const STRING& rhs) const
{
	STRING tmp;

	tmp.num = num + rhs.num;
	tmp.p = new char[num + rhs.num];

	memcpy(tmp.p, p, num);
	memcpy(tmp.p + num, rhs.p, rhs.num);

	return tmp;
}

bool STRING::operator<(const STRING& rhs) const
{
	return num < rhs.num;
}

//bool STRING::operator==(const STRING& rhs)
//{
//	return num < rhs.num;
//}

STRING STRING::operator=(const STRING& other)
{
	if (this == &other)
		return *this;

	if (num)
		delete[] p;

	num = other.num;
	p = new char[num];

	memcpy(p, other.p, num);

	if (관찰)
		print("복사할당");

	return *this;
}

STRING& STRING::operator=(STRING&& other) noexcept
{
	if (this != &other) {
		if (num)
			delete p;
		num = other.num;
		p = other.p;

		other.num = 0;
		other.p = nullptr;
	}

	if (관찰)
	{
		print("이동할당");
	}

	return *this;
}

void STRING::print(const char* s)
{
	std::cout << s << ", [" << id << "] 객체 : " << this;
	if (num)
	{
		std::cout << " 자원 수 : " << num << " 주소 : " << (void*)p;
	}
	else
	{
		std::cout << " 자원없음";
	}
	std::cout << std::endl;
}

size_t STRING::getNum()
{
	return num;
}


int STRING::cid{};

std::ostream& operator<<(std::ostream& os, const STRING& s)
{
	for (int i = 0; i < s.num; ++i)
		os << s.p[i];
	return os;
}

// 2022. 4. 28 추가
std::istream& operator>>(std::istream& is, STRING& s)
{
	std::string str;
	is >> str;
	s = str.c_str();
	return is;
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1484
저장 시간 : 2022-05-04 15:47:14 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일
// 수78목23 (6주 2일)
// 
// 컨테이너					- 다른 객체를 저장하는 객체
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// 반복자					- 포인터를 추상화한 것
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

template <class Iter, class Val>
Iter my_find(Iter b, Iter e, Val v)
{
	while (b != e) {
		if (*b == v)
			return b;
		++b;
	}
	return e;
}

template<class Iter>
void show(Iter)
{
	cout << "반복자 타입 : " << typeid(Iter).name() << endl;
	//cout << "반복자의 종류 : " << typename(iterator_traits<Iter>::iterator_category()).name() << endl;
}

// [문제]
// STRING에서 'k' 보다 큰 문자가 몇 번째인지 출력하라. 없으면 없다고 출력하라.
//

int main()
{
	save("소스.cpp");

	STRING s;			// 루프 최적화. 루프 안에서 선언되서 매번 초기화되는 변수를 루프 밖으로 들어 옮겨주는 컴파일러의 동작. loop optimization

	while (true)
	{
		cout << "단어를 입력하세요 : ";

		cin >> s;

		auto p = find_if(s.begin(), s.end(), [](char c) {
			return 'k' < c;
			});

		if (p == s.end())
			cout << "k보다 큰 글자 없다" << endl;
		else
			cout << distance(s.begin(), p) + 1 << " 위치에서 발견" << endl;
	}


}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1470
저장 시간 : 2022-05-04 15:47:45 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일
// 수78목23 (6주 2일)
// 
// 컨테이너					- 다른 객체를 저장하는 객체
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// 반복자					- 포인터를 추상화한 것
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

template <class Iter, class Val>
Iter my_find(Iter b, Iter e, Val v)
{
	while (b != e) {
		if (*b == v)
			return b;
		++b;
	}
	return e;
}

template<class Iter>
void show(Iter)
{
	cout << "반복자 타입 : " << typeid(Iter).name() << endl;
	//cout << "반복자의 종류 : " << typename(iterator_traits<Iter>::iterator_category()).name() << endl;
}

// [문제]
// STRING에서 대문자가 몇 번째인지 출력하라. 없으면 없다고 출력하라.
//

int main()
{
	save("소스.cpp");

	STRING s;			// 루프 최적화. 루프 안에서 선언되서 매번 초기화되는 변수를 루프 밖으로 들어 옮겨주는 컴파일러의 동작. loop optimization

	while (true)
	{
		cout << "단어를 입력하세요 : ";

		cin >> s;

		auto p = find_if(s.begin(), s.end(), [](char c) {
			return isupper(c);
			});

		if (p == s.end())
			cout << "대문자 없다" << endl;
		else
			cout << distance(s.begin(), p) + 1 << " 위치에서 발견" << endl;
	}


}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1474
저장 시간 : 2022-05-04 15:50:27 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일
// 수78목23 (6주 2일)
// 
// 컨테이너					- 다른 객체를 저장하는 객체
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// 반복자					- 포인터를 추상화한 것
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

template <class Iter, class Val>
Iter my_find_if(Iter b, Iter e, Val v)
{
	while (b != e) {
		if (v(*b))
			return b;
		++b;
	}
	return e;
}

template<class Iter>
void show(Iter)
{
	cout << "반복자 타입 : " << typeid(Iter).name() << endl;
	//cout << "반복자의 종류 : " << typename(iterator_traits<Iter>::iterator_category()).name() << endl;
}

// [문제]
// STRING에서 대문자가 몇 번째인지 출력하라. 없으면 없다고 출력하라.
//

int main()
{
	save("소스.cpp");

	STRING s;			// 루프 최적화. 루프 안에서 선언되서 매번 초기화되는 변수를 루프 밖으로 들어 옮겨주는 컴파일러의 동작. loop optimization

	while (true)
	{
		cout << "단어를 입력하세요 : ";

		cin >> s;

		auto p = my_find_if(s.begin(), s.end(), [](char c) {
			return isupper(c);
			});

		if (p == s.end())
			cout << "대문자 없다" << endl;
		else
			cout << distance(s.begin(), p) + 1 << " 위치에서 발견" << endl;
	}


}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1513
저장 시간 : 2022-05-04 16:10:13 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일
// 수78목23 (6주 2일)
// 
// 컨테이너					- 다른 객체를 저장하는 객체
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// 반복자					- 포인터를 추상화한 것
// 
// 반복자를 이해한다면 제네릭 함수를 만들어 볼 수 있겠다.
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

template <class Iter, class Call>
Iter my_find_if(Iter b, Iter e, Call f)
{
	while (b != e) {
		if (f(*b))
			return b;
		++b;
	}
	return e;
}

bool f(char c)
{
	return isupper(c);
}

// 람다의 정체
class XXX				// function object, functor
{
public:
	bool operator()(char c)
	{
		cout << "진짜로 돌아가는 중" << endl;
		return isupper(c);
	}
};

// [문제]
// STRING에서 대문자가 몇 번째인지 출력하라. 없으면 없다고 출력하라.
//

int main()
{
	save("소스.cpp");

	STRING s;			// 루프 최적화. 루프 안에서 선언되서 매번 초기화되는 변수를 루프 밖으로 들어 옮겨주는 컴파일러의 동작. loop optimization

	while (true)
	{
		cout << "단어를 입력하세요 : ";

		cin >> s;

		auto p = my_find_if(s.begin(), s.end(), XXX());

		if (p == s.end())
			cout << "대문자 없다" << endl;
		else
			cout << distance(s.begin(), p) + 1 << " 위치에서 발견" << endl;
	}


}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 947
저장 시간 : 2022-05-04 16:35:55 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일
// 수78목23 (6주 2일)
// 
// 컨테이너					- 다른 객체를 저장하는 객체
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// 반복자					- 포인터를 추상화한 것
// 
// 반복자를 이해한다면 제네릭 함수를 만들어 볼 수 있겠다.
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

template <class Input, class Output>
void my_copy(Input b, Input e, Output f)
{
	while (b != e) {
		*f = *b;
		++b;
		++f;
	}
}

// [문제]
// 키보드에서 입력한 문자를 그대로 화면에 출력하라.
//

int main()
{
	save("소스.cpp");

	

	my_copy(istream_iterator<char>{cin}, {}, ostream_iterator<char>{cout, " - "});
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1116
저장 시간 : 2022-05-04 16:54:45 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 5월 04일 수요일
// 수78목23 (9주 2일)
// 
// 컨테이너					- 다른 객체를 저장하는 객체
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// 반복자					- 포인터를 추상화한 것
// 
// 반복자를 이해한다면 제네릭 함수를 만들어 볼 수 있겠다.
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

template <class Input, class Output>
void my_copy(Input b, Input e, Output f)
{
	while (b != e) {
		*f = *b;
		++b;
		++f;
	}
}

// [문제]
// 키보드에서 입력한 문자를 그대로 화면에 출력하라.
//

int main()
{
	save("소스.cpp");

	vector<char> v;
	v.reserve(100);

	my_copy(istream_iterator<char>{cin}, {}, back_inserter(v));

	// back_inserter operator=  => container->push_back(_STD move(_Val));

	for (int i = 0; i < v.size(); ++i)
		cout << v[i] << " - ";
	cout << endl;
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1166
저장 시간 : 2022-05-04 17:12:54 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 5월 04일 수요일
// 수78목23 (9주 2일)
// 
// 컨테이너					- 다른 객체를 저장하는 객체
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// C++20 span - contiguous 컨테이너와 연결된 view를 말함.
//				배열이 인자로 전달될 때 size()를 알 수 없는 문제를 해결.
//				[], array, vector, string, STRING
//				-> 이것들을 일관되게 취급하려고 만든 view.
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <span>
#include <deque>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

void print(span<int>);

void print(span<int> a)			// 배열은 인자로 전달되면 포인터가 된다(type decay)
{
	cout << "전체 메모리 크기 : " << a.size_bytes() << endl;
	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << " - ";
	cout << endl;
}

// [문제]
// print 함수는 a를 인자로 받아 전체 원소를 출력한다.
// 선언하고 정의하라.
//

int main()
{
	int a[10]{ 1,2,3,4,5 };

	print(a);

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1912
저장 시간 : 2022-05-11 16:04:01 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 5월 11일 수요일
// 수78목23 (10주 2일)
// 
// 5월 25일 졸작 설명회
// 5/30 ~ 6/20 지도교수 신청일
// 
// Associative Container - set, multi_set, map, multi_map
// set - 언제나 key를 compare로 정렬하고 있다. 찾기/추가/삭제 O(log N)
//      - set의 주요 동작을 알아본다. (빨리 찾기 위한 컨테이너)
//      - 내가 만든 자료형(class Dog)을 set에 넣어 관리
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <set>
#include <string>
#include <list>
#include <random>

#include "save.h"
#include "STRING.h"

using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uid{ 'a','z' };
uniform_int_distribution<int> uidN{ 1, 10000 };

class Dog
{
	string name;
	int n;

public:
	Dog()
	{
		for (int i = 0; i < 10; ++i)
			name += uid(dre);

		n = uidN(dre);
	}

	bool operator<(const Dog& rhs) const
	{
		return n < rhs.n;
	}

	string getName() const { return name; }

	int getN() const { return n; }

	void show() const
	{
		cout << name << " - " << n << endl;
	}

};
extern bool 관찰;

// [문제]
// set에다가 내가 만든 자료형 Dog을 넣고싶다.
// 정렬 기준n오름차순으로 항상 정렬하는 set을 만들고 싶다.
//

auto 정렬기준 = [](const Dog& a, const Dog& b)
{
	return a.getN() < b.getN();
};

int main()
{
	save("소스.cpp");

	multiset<Dog, decltype(정렬기준)> s;

	for (int i = 0; i < 1000; ++i)
	{
		s.emplace( );
	}

	cout << "셋의 원소 수 - " << s.size() << endl;

	for (const Dog& dog : s)
		dog.show();

	// 기준이 없어요?
	// 1. less<Dog>가 있나 살펴본다.
	// 2. class Dog이 < 연산자를 제공하고 있는지 살펴본다.
	//   - 2.1 멤버 - 코딩가능하면 멤버로 만든다.
	//	 - 2.2 전역
	// 3. 기준을 직접 템플릿 인자로 제공한다.
	//

}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1907
저장 시간 : 2022-05-11 16:04:22 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 5월 11일 수요일
// 수78목23 (10주 2일)
// 
// 5월 25일 졸작 설명회
// 5/30 ~ 6/20 지도교수 신청일
// 
// Associative Container - set, multi_set, map, multi_map
// set - 언제나 key를 compare로 정렬하고 있다. 찾기/추가/삭제 O(log N)
//      - set의 주요 동작을 알아본다. (빨리 찾기 위한 컨테이너)
//      - 내가 만든 자료형(class Dog)을 set에 넣어 관리
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <set>
#include <string>
#include <list>
#include <random>

#include "save.h"
#include "STRING.h"

using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uid{ 'a','z' };
uniform_int_distribution<int> uidN{ 1, 10000 };

class Dog
{
	string name;
	int n;

public:
	Dog()
	{
		for (int i = 0; i < 10; ++i)
			name += uid(dre);

		n = uidN(dre);
	}

	bool operator<(const Dog& rhs) const
	{
		return n < rhs.n;
	}

	string getName() const { return name; }

	int getN() const { return n; }

	void show() const
	{
		cout << name << " - " << n << endl;
	}

};
extern bool 관찰;

// [문제]
// set에다가 내가 만든 자료형 Dog을 넣고싶다.
// 정렬 기준n오름차순으로 항상 정렬하는 set을 만들고 싶다.
//

auto 정렬기준 = [](const Dog& a, const Dog& b)
{
	return a.getN() < b.getN();
};

int main()
{
	save("소스.cpp");

	set<Dog, decltype(정렬기준)> s;

	for (int i = 0; i < 1000; ++i)
	{
		s.emplace( );
	}

	cout << "셋의 원소 수 - " << s.size() << endl;

	for (const Dog& dog : s)
		dog.show();

	// 기준이 없어요?
	// 1. less<Dog>가 있나 살펴본다.
	// 2. class Dog이 < 연산자를 제공하고 있는지 살펴본다.
	//   - 2.1 멤버 - 코딩가능하면 멤버로 만든다.
	//	 - 2.2 전역
	// 3. 기준을 직접 템플릿 인자로 제공한다.
	//

}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1159
저장 시간 : 2022-05-11 16:36:18 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 5월 11일 수요일
// 수78목23 (10주 2일)
// 
// 5월 25일 졸작 설명회(수 56교시)
// 5/30 ~ 6/20 지도교수 신청일
// 
// Associative Container - set, multi_set, map, multi_map
// set - 언제나 key를 compare로 정렬하고 있다. 찾기/추가/삭제 O(log N)
//      - set의 주요 동작을 알아본다. (빨리 찾기 위한 컨테이너)
//      - 내가 만든 자료형(class Dog)을 set에 넣어 관리
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <set>
#include <format>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제]
// 키보드 입력한 단어를 set<STRING>에 넣어라
// set<STRING>의 정렬기준은 단어길이 오름차순이다
// set을 화면에 출력하라
//

class 길이순
{
public:
	bool operator()(const STRING& a, const STRING& b) const
	{
		return a.getNum() < b.getNum();
	}
};

int main()
{
	save("소스.cpp");

	set<STRING, 길이순> s{ istream_iterator<STRING>{cin}, {} };
	
	for (const STRING& word : s)
		cout << word << endl;

}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1939
저장 시간 : 2022-05-11 17:14:21 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 5월 11일 수요일
// 수78목23 (10주 2일)
// 
// 5월 25일 졸작 설명회(수 56교시)
// 5/30 ~ 6/20 지도교수 신청일
// 
// Sequential Cntainer - array, vector, deque, fowardlist, list
// Associative Container - set, multi_set, map, multi_map
//	map<key, value, key_compare>
//		- 
// 
// unordered Associative Container - u_set, u_multiset, u_map, u_multimap
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <map>
#include <vector>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제]
// key : 영화시간, value : 배우들
// 영화 제목을 입력받아 있으면 배우를 출력하라.
//

int main()
{
	save("소스.cpp");
	
	map<string, vector<string>> movie;

	movie.insert({ "기생충", { "이선균", "고여정", "최우식", "박소담" }});

	pair<string, vector<string>> p{ "쇼생크탈출", {"팀 로빈슨"}};

	movie.insert(p);

	movie.insert(make_pair<string, vector<string>>("관상", { "이정재","송강호" }));

	/*for (const pair<string, vector<string>>& m : movie)
	{
		cout << m.first << " - ";
		for (const string& actor : m.second)
			cout << actor << " ";
		cout << endl;
	}*/

	for (const auto& [제목, 배우들] : movie)
	{
		cout << 제목 << " - ";
		for (const auto& 배우 : 배우들)
			cout << 배우 << " ";
		cout << endl;
	}

	while (true)
	{
		string title;

		cout << "영화제목을 입력하세요. : ";
		
		cin >> title;

		auto p = movie.find(title);

		if (p != movie.end())
		{
			/*
			cout << p->first << " ";
			for (auto 배우 : p->second)
				cout << 배우 << " ";
			cout << endl;
			*/
			auto [제목, 배우들] = *p;
			cout << 제목 << " ";
			for (auto 배우 : 배우들)
				cout << 배우 << " ";
			cout << endl;
		}
		else
			cout << "없는디유?" << endl;
	}
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1167
저장 시간 : 2022-05-12 10:39:17 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 5월 12일 목요일
// 수78목23 (11주 1일)
// 
// 5월 25일 졸작 설명회(수 56교시)
// 5/30 ~ 6/20 지도교수 신청일
// 
// Sequential Cntainer - array, vector, deque, fowardlist, list
// Associative Container - set, multi_set, map, multi_map
//	map<key, value, key_compare>
//		- 연관배열(associative array)로 사용할 수 있다.
// PHP?
// 
// unordered Associative Container - u_set, u_multiset, u_map, u_multimap
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <map>
#include <fstream>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제]
// 소설에 사용된 알파벳의 빈도수를 출력하라.
//

int main()
{
	// 이름과 전화번호 
	map<string, string> m;

	m.insert(pair("홍길동", "01012345678"));

	m["마우스"] = "12345678";				// 연관배열로 사용하는 것이 이해하기 편함. 집어 넣는데에 사용되기도 하고 읽을때 사용하기도 함.

	for (auto [이름, 번호] : m)
		cout << 이름 << " - " << 번호 << endl;

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1231
저장 시간 : 2022-05-12 10:49:53 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 5월 12일 목요일
// 수78목23 (11주 1일)
// 
// 5월 25일 졸작 설명회(수 56교시)
// 5/30 ~ 6/20 지도교수 신청일
// 
// Sequential Cntainer - array, vector, deque, fowardlist, list
// Associative Container - set, multi_set, map, multi_map
//	map<key, value, key_compare>
//		- 연관배열(associative array)로 사용할 수 있다.
// PHP?
// 
// unordered Associative Container - u_set, u_multiset, u_map, u_multimap
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <map>
#include <fstream>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제]
// 소설에 사용된 알파벳의 빈도수를 출력하라.
// 파일을 vector<string>에 읽어 몇 단어인지 화면에 출력하라.
//

int main()
{
	ifstream in{ "Frankenstein.txt" };
	vector<string> v{ istream_iterator<string>{in},{} };
	map<string, int> m{};
	
	for (string s : v)
		m[s]++;
	for (auto s : m)
		cout << s.first << " - " << s.second << endl;

	cout << v.size() << endl;
	cout << m.size() << endl;

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1194
저장 시간 : 2022-05-12 10:57:58 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 5월 12일 목요일
// 수78목23 (11주 1일)
// 
// 5월 25일 졸작 설명회(수 56교시)
// 5/30 ~ 6/20 지도교수 신청일
// 
// Sequential Cntainer - array, vector, deque, fowardlist, list
// Associative Container - set, multi_set, map, multi_map
//	map<key, value, key_compare>
//		- 연관배열(associative array)로 사용할 수 있다.
// PHP?
// 
// unordered Associative Container - u_set, u_multiset, u_map, u_multimap
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <map>
#include <fstream>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제]
// 이 소설에서 각 소문자의 빈도를 세라.
//

int main()
{
	ifstream in{ "Frankenstein.txt" };
	vector<string> v{ istream_iterator<string>{in},{} };
	map<string, int> m{};
	
	for (string s : v)
		m[s]++;

	cout << "가장 긴 단어 - " << *max_element(v.begin(), v.end(), [](string a, string b) {return a.length() < b.length(); }) << endl;

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 2223
저장 시간 : 2022-05-12 12:00:36 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 5월 12일 목요일
// 수78목23 (11주 1일)
// 
// 5월 25일 졸작 설명회(수 56교시)
// 5/30 ~ 6/20 지도교수 신청일
// 
// Sequential Cntainer - array, vector, deque, fowardlist, list
// Associative Container - set, multi_set, map, multi_map
//	map<key, value, key_compare>
//		- 연관배열(associative array)로 사용할 수 있다.
// PHP?
// 
// unordered Associative Container - u_set, u_multiset, u_map, u_multimap
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <map>
#include <fstream>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제]
// 이 소설에서 각 소문자의 빈도를 세라.
// 가장 많이 사용된 단어 순으로 출력하라.
//

int main()
{
	ifstream in{ "Frankenstein.txt" };
	vector<string> v{ istream_iterator<string>{in},{} };
	map<char, int> mc{};
	
	for (string s : v)
	{
		for (char c : s)
		{
			if (islower(c))
				mc[c]++;
		}
	}

	/*
	vector<pair<char, int>> sv{ mc.begin(),mc.end() };

	sort(sv.begin(), sv.end(), [](const pair<char, int>& a, const pair<char, int>& b) {return a.second > b.second; });

	for (auto [소문자, 갯수] : sv)
		cout << "[" << 소문자 << "] - " << 갯수 << endl;
	*/

	/*map<char, int, greater<int>> mcig{};

	for (auto [소문자, 갯수] : mc)
		mcig[소문자] = 갯수;

	for (auto [소문자, 갯수] : mcig)
		cout << "[" << 소문자 << "] - " << 갯수 << endl;*/

	map<string, int> si{};

	for (const string& s : v)
		si[s]++;

	multimap<int, string, greater<int>> sis{};
	for (auto [단어, 갯수] : si)
		sis.emplace(make_pair(갯수, 단어));

	//// 앞에서부터 20개만

	//auto p = sis.begin();
	//for (int i = 0; i < 20; ++i, ++p)
	//	cout << p->second << " - " << p->first << endl;

	// 뒤에서부터 20개만

	auto p = sis.rbegin();
	for (int i = 0; i < 20; ++i, ++p)
		cout << p->second << " - " << p->first << endl;

	// 단어 갯수가 75041개인지 검증한다.
	int cnt{};
	for (auto [갯수, 단어] : sis)
		cnt += 갯수;
	cout << cnt << endl;

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1211
저장 시간 : 2022-05-12 12:04:35 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 5월 12일 목요일
// 수78목23 (11주 1일)
// 
// 5월 25일 졸작 설명회(수 56교시)
// 5/30 ~ 6/20 지도교수 신청일
// 
// Sequential Cntainer - array, vector, deque, fowardlist, list
// Associative Container - set, multi_set, map, multi_map
//	map<key, value, key_compare>
//		- 연관배열(associative array)로 사용할 수 있다.
// PHP?
// 
// unordered Associative Container - u_set, u_multiset, u_map, u_multimap
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <map>
#include <fstream>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제]
// 이 소설에서 각 소문자의 빈도를 세라.
// 가장 많이 사용된 단어 순으로 출력하라.
//

int main()
{
	ifstream in{ "Frankenstein.txt" };
	vector<string> v{ istream_iterator<string>{in},{} };

	// 길이가 16인 단어만 화면에 출력.
	
	copy_if(v.begin(), v.end(), ostream_iterator<string>{cout, "\n"}, [](const string& s) {
		return s.length() == 16;
		});

	save("소스.cpp");
}

array<int, 10000000> a;
default_random_engine dre;
uniform_int_distribution uid{ 1, 10000000 };

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1390
저장 시간 : 2022-05-18 15:56:17 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 5월 18일 수요일
// 수78목23 (11주 2일)
// 
// 5월 25일 졸작 설명회(수 56교시)
// 5/30 ~ 6/20 지도교수 신청일
// 
// Sequential Cntainer - array, vector, deque, fowardlist, list
// Associative Container - set, multi_set, map, multi_map
// 
// Unordered Associative Container - u_set, u_multiset, u_map, u_multimap
//  - 어떻게 메모리가 구성되어 있나? - 그림으로 알아본다.
//  - 내가 만든 STRING을 원소로 순서없는 set의 원소가 되려면?
// 
// 컨테이너의 찾기 실력 검증 - vector / set / unordered_set
// 
//----------------------------------------------------------------------------------------
#include <iostream>

#include "save.h"
#include "STRING.h"
#include <unordered_set>
#include <unordered_map>

using namespace std;

extern bool 관찰;

// [문제]
// 유니폼분포가 진짜 유니폼한가?
// 결과를 출력해서 알아본다.
//

int main()
{		
	save("소스.cpp");

	unordered_set<int> us{ 1,2,3,4 };

	while (true)
	{
		// 메모리 내용 출력
		for (int i{}; i < us.bucket_count(); ++i)
		{
			cout << "[" << i << "] ";
			for (auto p = us.begin(i); p != us.end(i); ++p)
				cout << "-> " << *p;
			cout << endl;
		}
		cout << endl;

		// 새로운 원소 추가
		cout << "추가할 int는? : ";
		int num;
		cin >> num;
		us.insert(num);

	}

}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1775
저장 시간 : 2022-05-18 16:16:32 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 5월 18일 수요일
// 수78목23 (11주 2일)
// 
// 5월 25일 졸작 설명회(수 56교시)
// 5/30 ~ 6/20 지도교수 신청일
// 
// Sequential Cntainer - array, vector, deque, fowardlist, list
// Associative Container - set, multi_set, map, multi_map
// 
// Unordered Associative Container - u_set, u_multiset, u_map, u_multimap
//  - 어떻게 메모리가 구성되어 있나? - 그림으로 알아본다.
//  - 내가 만든 STRING을 원소로 순서없는 set의 원소가 되려면?
// 
// 컨테이너의 찾기 실력 검증 - vector / set / unordered_set
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <unordered_set>
#include <unordered_map>
#include <string>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// 클래스 특수화, class specialization. 클래스 일반화는 class generalization
template<>
class hash<STRING>
{
public:
	size_t operator()(const STRING& str) const 
	{
		auto val = hash<string>()({ str.begin(),str.end() });
		cout << "해셔의 출력 - " << val << ", 메모리의 위치 - " << val % 8 << endl;
		return val;
	}
};

// [문제]
// 유니폼분포가 진짜 유니폼한가?
// 결과를 출력해서 알아본다.
//

int main()
{
	save("소스.cpp");

	unordered_set<STRING> us{ "Standard", "Template", "Library" };

	while (true)
	{
		// 메모리 내용 출력
		for (int i{}; i < us.bucket_count(); ++i)
		{
			cout << "[" << i << "] ";
			for (auto p = us.begin(i); p != us.end(i); ++p)
				cout << "-> " << *p;
			cout << endl;
		}
		cout << endl;

		// 새로운 원소 추가
		cout << "추가할 STRING은? : ";
		STRING str;
		cin >> str;
		us.insert(str);

	}

}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 3887
저장 시간 : 2022-05-18 17:01:41 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 5월 18일 수요일
// 수78목23 (11주 2일)
// 
// 5월 25일 졸작 설명회(수 56교시)
// 5/30 ~ 6/20 지도교수 신청일
// 
// Sequential Cntainer - array, vector, deque, fowardlist, list
// Associative Container - set, multi_set, map, multi_map
// 
// Unordered Associative Container - u_set, u_multiset, u_map, u_multimap
//  - 어떻게 메모리가 구성되어 있나? - 그림으로 알아본다.
//  - 내가 만든 STRING을 원소로 순서없는 set의 원소가 되려면?
// 
// 컨테이너의 찾기 실력 검증 - vector / set / unordered_set
// int 
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <vector>
#include <set>
#include <unordered_set>
#include <algorithm>
#include <random>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제]
// 정수 1000만개 저장할 메모리
//
array<int, 1000'0000> numbers;

// 컨테이너에 있나 찾아볼 int 값들
array<int, 10'000> toFind;

default_random_engine dre;
uniform_int_distribution uid{ 1,1'0000'0000 };

int main()
{
	save("소스.cpp");

	// 천만개 랜덤생성
	for (int& n : numbers)
		n = uid(dre);
	// 천개 랜덤생성
	for (int& n : toFind)
		n = uid(dre);

	{
		auto time = clock();

		int cnt{};
		// 벡터의 찾기실력을 알아본다.
		vector<int> v{ numbers.begin(),numbers.end() };

		cout << "벡터의 원소 개수 - " << v.size() << endl;
		cout << "걸린 시간 - " << (double)(clock() - time) / CLOCKS_PER_SEC << "초" << endl << endl;

		time = clock();

		for (int n : toFind)
		{
			auto p = find(v.begin(), v.end(), n);
			if (p != v.end())
				cnt++;
		}
		cout << "찾아야 할 int 개수 - " << toFind.size() << endl;
		cout << "벡터에서 찾은 개수 - " << cnt << endl << endl;
		cout << "걸린 시간 (O(n)) - " << (double)(clock() - time) / CLOCKS_PER_SEC << "초" << endl << endl;
	}
	{
		auto time = clock();
		int cnt{};
		// 셋의 찾기실력을 알아본다.
		set<int> s{ numbers.begin(),numbers.end() };

		cout << "셋의 원소 개수 - " << s.size() << endl;
		cout << "걸린 시간 - " << (double)(clock() - time) / CLOCKS_PER_SEC << "초" << endl << endl;

		time = clock();

		for (int n : toFind)
		{
			if (s.contains(n))
				cnt++;
		}
		cout << "찾아야 할 int 개수 - " << toFind.size() << endl;
		cout << "셋에서 찾은 개수 - " << cnt << endl << endl;
		cout << "걸린 시간 (O(log n)) - " << (double)(clock() - time) / CLOCKS_PER_SEC << "초" << endl << endl;
	}
	{
		auto time = clock();
		int cnt{};
		// 언오더드셋의 찾기실력을 알아본다.
		unordered_set<int> us{ numbers.begin(),numbers.end() };

		cout << "언오더드셋의 원소 개수 - " << us.size() << endl;
		cout << "걸린 시간 - " << (double)(clock() - time) / CLOCKS_PER_SEC << "초" << endl << endl;

		time = clock();

		for (int n : toFind)
		{
			if (us.contains(n))
				cnt++;
		}
		cout << "찾아야 할 int 개수 - " << toFind.size() << endl;
		cout << "언오더드셋에서 찾은 개수 - " << cnt << endl << endl;
		cout << "걸린 시간 (O(1)) - " << (double)(clock() - time) / CLOCKS_PER_SEC << "초" << endl << endl;
	}

	{
		auto time = clock();

		int cnt{};
		// 정렬된 벡터의 찾기실력을 알아본다.
		vector<int> v{ numbers.begin(),numbers.end() };
		sort(v.begin(), v.end());

		cout << "정렬된 벡터의 원소 개수 - " << v.size() << endl;
		cout << "걸린 시간 - " << (double)(clock() - time) / CLOCKS_PER_SEC << "초" << endl << endl;

		time = clock();

		for (int n : toFind)
		{
			if (binary_search(v.begin(), v.end(), n))
				cnt++;
		}
		cout << "찾아야 할 int 개수 - " << toFind.size() << endl;
		cout << "정렬된 벡터에서 찾은 개수 - " << cnt << endl << endl;
		cout << "걸린 시간 (O(log n)) - " << (double)(clock() - time) / CLOCKS_PER_SEC << "초" << endl << endl;
	}

}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1187
저장 시간 : 2022-05-19 11:01:02 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 5월 18일 수요일
// 수78목23 (11주 2일)
// 
// 5월 25일 졸작 설명회(수 56교시)
// 5/30 ~ 6/20 지도교수 신청일
// 
// 알고리즘
//  - non-modifying sequence operation(원소를 수정하지 않는 알고리즘)
// 
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제]
// v에 STRING이 있는데 첫글자가 다 대문자인가?
//

template<class InputIt, class Undefined>
bool allof(InputIt begin, InputIt end, Undefined un)
{
	//return find_if_not(begin, end, un) == end;
	while (begin != end)
	{
		if (!un(*begin))
			retrun false;
		begin++;
	}
	return true;
}

int main()
{
	vector<STRING> v{ "Standard", "Template", "Library" };

	bool res = all_of(v.cbegin(), v.cend(), [](const STRING& str) {return isupper(*str.begin()); });

	if (res)
		cout << "첫 글자 다 대문자" << endl;
	else
		cout << "소문자로 시작하는 단어도 있다" << endl;

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 857
저장 시간 : 2022-05-19 11:08:27 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 5월 19일 목요일
// 수78목23 (12주 1일)
// 
// 5월 25일 졸작 설명회(수 56교시)
// 5/30 ~ 6/20 지도교수 신청일
// 
// 알고리즘
//  - non-modifying sequence operation(원소를 수정하지 않는 알고리즘)
// 
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제]
// 앞이 T인 원소가 몇 개인가?
//

bool X(const STRING& str)
{
	if (*str.begin() == 'T')
		return true;
	return false;
}

int main()
{
	vector<STRING> v{ "Standard", "Template", "Library" };

	cout << count_if(v.begin(), v.end(), X) << endl;

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 935
저장 시간 : 2022-05-19 11:29:05 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 5월 19일 목요일
// 수78목23 (12주 1일)
// 
// 5월 25일 졸작 설명회(수 56교시)
// 5/30 ~ 6/20 지도교수 신청일
// 
// 알고리즘
//  - non-modifying sequence operation(원소를 수정하지 않는 알고리즘)
// 
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제]
// 앞이 T인 원소가 몇 개인가?
//

int main()
{
	string s1{ "abcdefghij" };
	string s2{ "abcdfghijklll" };

	auto [첫인자, 끝인자] = mismatch(s1.begin(), s1.end(), s2.begin(), s2.end());

	string s3{ 첫인자, s1.end()};

	string s4{ 끝인자, s2.end() };

	cout << "결과 - " << s3 << ", " << s4 << endl;

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 980
저장 시간 : 2022-05-19 11:41:56 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 5월 19일 목요일
// 수78목23 (12주 1일)
// 
// 5월 25일 졸작 설명회(수 56교시)
// 5/30 ~ 6/20 지도교수 신청일
// 
// 알고리즘
//  - non-modifying sequence operation(원소를 수정하지 않는 알고리즘)
// 
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <thread>
#include <format>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제]
// 전광판처럼 흘러가게 찍어보자.
//

int main()
{
	save("소스.cpp");

	string str{ "South Korea and Japan just don't get along." };

	for (int i = 0; i < 12; ++i)
		cout << endl;

	while (true)
	{
		rotate(str.begin(), str.begin() + 1, str.end());
		cout << format("{:^80}",str) << "\r";
		this_thread::sleep_for(100ms);
	}

}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 904
저장 시간 : 2022-05-25 15:42:20 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 5월 25일 수요일
// 수78목23 (12주 1일)
// 
// 5월 25일 졸작 설명회(수 56교시)
// 5/30 ~ 6/20 지도교수 신청일
// 
// 알고리즘
//  - non-modifying sequence operation(원소를 수정하지 않는 알고리즘)
// 
// 시험 - 15주 1일 : 6월 15일 수요일
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <vector>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제]
// copy는 왜 mutating 알고리즘인가?
//

int main()
{
	vector v{ 1,2,3,4,5 };
	// 목적지가 자기 자신이 될 수 있기 때문에 mutating 알고리즘이다.

	copy(v.begin(), v.end(), inserter(v, v.begin() + 1));

	for (int i : v)
		cout << i << " ";
	cout << endl;

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 937
저장 시간 : 2022-05-25 15:48:30 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 5월 25일 수요일
// 수78목23 (12주 1일)
// 
// 5월 25일 졸작 설명회(수 56교시)
// 5/30 ~ 6/20 지도교수 신청일
// 
// 알고리즘
//  - non-modifying sequence operation(원소를 수정하지 않는 알고리즘)
// 
// 시험 - 15주 1일 : 6월 15일 수요일
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <vector>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제]
// 벡터에서 짝수를 지워라.
//

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	// erase-remove idiom : 둘이 세트로 자주 쓰인다는 뜻.
	v.erase(remove_if(v.begin(), v.end(), [](int i) {return i % 2 == 0; }), v.end());

	for (int i : v)
		cout << i << " ";
	cout << endl;

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1083
저장 시간 : 2022-05-25 15:51:08 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 5월 25일 수요일
// 수78목23 (12주 1일)
// 
// 5월 25일 졸작 설명회(수 56교시)
// 5/30 ~ 6/20 지도교수 신청일
// 
// 알고리즘
//  - non-modifying sequence operation(원소를 수정하지 않는 알고리즘)
// 
// 시험 - 15주 1일 : 6월 15일 수요일
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <vector>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제]
// 벡터에서 짝수를 지워라.
//

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	// erase-remove idiom : 둘이 세트로 자주 쓰인다는 뜻.
	// erase-remove idiom이 원칙이지만 c++20 부터는 지원되는 전역 erase 함수를 이용해도 해결 가능
	//v.erase(remove_if(v.begin(), v.end(), [](int i) {return i % 2 == 0; }), v.end());
	erase_if(v, [](int i) {return i % 2 == 0; });

	for (int i : v)
		cout << i << " ";
	cout << endl;

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1094
저장 시간 : 2022-05-25 16:04:49 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 5월 25일 수요일
// 수78목23 (12주 1일)
// 
// 5월 25일 졸작 설명회(수 56교시)
// 5/30 ~ 6/20 지도교수 신청일
// 
// 알고리즘
//  - non-modifying sequence operation(원소를 수정하지 않는 알고리즘)
// 
// 시험 - 15주 1일 : 6월 15일 수요일
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <vector>
#include <numeric>
#include <random>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

random_device rd;
default_random_engine dre{ rd() };

// [문제]
// 랜덤한 수 n개를 화면에 출력
//

int main()
{
	//vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	// sample : 로또 번호뽑는 알고리즘

	vector<int> v(45);		// int{}를 45번 호출

	iota(v.begin(), v.end(), 1);

	//for (int i : v)
	//	cout << i << " ";
	//cout << endl;

	sample(v.begin(), v.end(), ostream_iterator<int>{cout, " "}, 6, dre);

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 811
저장 시간 : 2022-05-25 16:10:30 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 5월 25일 수요일
// 수78목23 (12주 1일)
// 
// 5월 25일 졸작 설명회(수 56교시)
// 5/30 ~ 6/20 지도교수 신청일
// 
// 알고리즘
//  - non-modifying sequence operation(원소를 수정하지 않는 알고리즘)
// 
// 시험 - 15주 1일 : 6월 15일 수요일
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <vector>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제]
// 
//

int main()
{
	vector<int> v{ 1, 2, 3, 3, 3, 5, 3 };

	v.erase(unique(v.begin(), v.end()),v.end());

	for (int i : v)
		cout << i << " ";
	cout << endl;

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1029
저장 시간 : 2022-05-25 16:18:49 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 5월 25일 수요일
// 수78목23 (12주 1일)
// 
// 5월 25일 졸작 설명회(수 56교시)
// 5/30 ~ 6/20 지도교수 신청일
// 
// 알고리즘
//  - non-modifying sequence operation(원소를 수정하지 않는 알고리즘)
// 
// 시험 - 15주 1일 : 6월 15일 수요일
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <vector>
#include <fstream>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제]
// 프랑켄슈타인.txt는 모두 몇 개의 unique한 word로 이루어졌나?
//

int main()
{
	ifstream in{ "Frankenstein.txt" };

	vector<string> v{ istream_iterator<string>{in},{} };

	cout << "중복 단어 제거 전 - " << v.size() << endl;

	sort(v.begin(), v.end());

	v.erase(unique(v.begin(), v.end()),v.end());

	cout << "중복 단어 제거 후 - " << v.size() << endl;

	save("소스.cpp");
}