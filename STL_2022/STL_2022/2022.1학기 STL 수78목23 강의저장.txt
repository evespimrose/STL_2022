===================================================================
파일 이름 : 소스.cpp
파일크기 : 1662
저장 시간 : 2022-03-02 17:11:22 GMT+9
===================================================================
파일 이름 : 소스.cpp
파일크기 : 1809
저장 시간 : 2022-03-02 17:14:58 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 2일 수요일
// 수78목23 (1주 1일)
// 
// - 강의 소개
// - cppreference.com
// - google coding convention을 참고
// - 프로젝트 환경설정 통일
// 
// 할일 - 한학기 코딩한 내용을 저장할 수 있게 save 기능 완성
//----------------------------------------------------------------------------------------

#include <iostream>
#include <string_view>
#include <filesystem>
#include <chrono>
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;

//void save(const char*)
//void save(const string&)
void save(string_view fname)
{

	// 읽을 파일을 연다
	// 쓸 파일을 연다.
	ifstream in{ fname.data() };
	ofstream out{ "2022.1학기 STL 수78목23 강의저장.txt" , ios::app };

	// 저장할 파일 이름과 크기를 출력한다.
	out << "===================================================================" << endl;
	out << "파일 이름 : " << fname << endl;
	out << "파일크기 : " << filesystem::file_size(fname) << endl;

	// 현재 날짜와 시간(C++20)을 출력한다.
	auto time = floor<chrono::seconds>(chrono::system_clock::now());
	out << "저장 시간 : " << chrono::zoned_time("Asia/Seoul", time) << endl;

	// 읽은 파일을 강의저장 파일에 덧붙인다.
	// 1. 벡터에 파일을 읽어온다.
	//vector<char> v{ istream_iterator<char>{in},{} };
	vector<char> v{ istreambuf_iterator<char>{in},{} };

	// 2. copy 알고리즘을 이용해 벡터에 있는 글자를 가으이저장파일로 복사한다,
	copy(v.begin(), v.end(), ostream_iterator<char>{out});
}

int main()
{
	// string과 string_view의 크기 확인
	// 서로의 크기가 다른 이유?
	string a;
	string_view b;
	cout << "string의 크기 - " << sizeof(a) << endl << "string_view의 크기 - " << sizeof(b) << endl;
	save("소스.cpp");
}
===================================================================
파일 이름 : 소스.cpp
파일크기 : 692
저장 시간 : 2022-03-03 10:47:27 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일
// 수78목23 (1주 2일)
// 
// 
// 할일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <string_view>
#include <filesystem>
#include <chrono>
#include <fstream>
#include <vector>
#include <algorithm>

#include "save.h"

using namespace std;

int main()
{
	string a;
	string_view b;
	cout << "string의 크기 - " << sizeof(a) << endl << "string_view의 크기 - " << sizeof(b) << endl;
	save("소스.cpp");
}
===================================================================
파일 이름 : save.h
파일크기 : 76
저장 시간 : 2022-03-03 11:03:43 GMT+9
#pragma once

#include <string_view>

void save(std::string_view fname);===================================================================
파일 이름 : save.cpp
파일크기 : 1563
저장 시간 : 2022-03-03 11:03:43 GMT+9
//----------------------------------------------------------------------------------------
// SAVE.CPP
// 
// 이 함수를 호출하면 "2022.1학기 STL 수78목23 강의저장.txt"에
// 전달된 이름의 파일을 읽어 덧붙인다.
// 2022. 3. 3								BY JHT
//----------------------------------------------------------------------------------------

#include <iostream>
#include <filesystem>
#include <chrono>
#include <fstream>
#include <vector>
#include <algorithm>

#include "save.h"

//void save(const char*)
//void save(const string&)
void save(std::string_view fname)
{

	// 읽을 파일을 연다 - RALL
	std::ifstream in{ fname.data() };


	// 쓸 파일을 연다.
	std::ofstream out{ "2022.1학기 STL 수78목23 강의저장.txt" , std::ios::app };

	// 저장할 파일 이름과 크기(C++17)를 출력한다.
	out << "===================================================================" << std::endl;
	out << "파일 이름 : " << fname << std::endl;
	out << "파일크기 : " << std::filesystem::file_size(fname) << std::endl;

	// 현재 날짜와 시간(C++20)을 출력한다.
	auto time = floor<std::chrono::seconds>(std::chrono::system_clock::now());
	out << "저장 시간 : " << std::chrono::zoned_time("Asia/Seoul", time) << std::endl;

	// 읽은 파일을 강의저장 파일에 덧붙인다.

	// 1. 벡터에 파일을 읽어온다. - 컨테이너
	//vector<char> v{ istream_iterator<char>{in},{} };
	std::vector<char> v{ std::istreambuf_iterator<char>{in},{} };

	// 2. copy 알고리즘을 이용해 벡터에 있는 글자를 강의저장파일로 복사한다,
	copy(v.begin(), v.end(), std::ostream_iterator<char>{out});
}===================================================================
파일 이름 : 소스.cpp
파일크기 : 475
저장 시간 : 2022-03-03 11:03:43 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일
// 수78목23 (1주 2일)
// 
// 
// 할일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
//----------------------------------------------------------------------------------------

#include <iostream>

#include "save.h"

using namespace std;

int main()
{
	save("save.h");
	save("save.cpp");
	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 687
저장 시간 : 2022-03-03 11:19:56 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일
// 수78목23 (1주 2일)
// 
// 
// 할일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
//----------------------------------------------------------------------------------------

#include <iostream>

#include "save.h"

using namespace std;

void change(int& a, int& b)
{
	int tmp;
	tmp = a;
	a = b;
	b = tmp;
}

// [문제] main()을 변경하면 안된다.
// 실행하면 a와 b의 값이 서로 바껴야 한다.
//

int main()
{
	int a{ 1 };
	int b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;

	save("소스.cpp");
}
===================================================================
파일 이름 : 소스.cpp
파일크기 : 1013
저장 시간 : 2022-03-03 11:37:24 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일
// 수78목23 (1주 2일)
// 
// 
// 할일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
//----------------------------------------------------------------------------------------

#include <iostream>

#include "save.h"

using namespace std;

// 교수님 답
void change(int&, int&);

// 내 답
//void change(int& a, int& b)
//{
//	int tmp{};
//	tmp = a;
//	a = b;
//	b = tmp;
//}

// [문제] main()을 변경하면 안된다.
// 실행하면 a와 b의 값이 서로 바껴야 한다.
// 참조인자로 전달하지 않으면 매개변수를 복사본으로 전달해 함수에서 바꾸어도 원본인 변수의 값은 변경되지 않는다.
// 클래스 안에서 레퍼런스는 복사본이 아닌 원본을 이용하라는 뜻이다.

int main()
{
	int a{ 1 };
	int b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;

	save("소스.cpp");
}

void change(int& a, int& b)
{
	int tmp{};
	tmp = a;
	a = b;
	b = tmp;
}


===================================================================
파일 이름 : 소스.cpp
파일크기 : 1063
저장 시간 : 2022-03-03 12:17:48 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일
// 수78목23 (1주 2일)
// 
// 
// 할일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
// &의 의미를 복습
// class를 복습
// 
//----------------------------------------------------------------------------------------

#include <iostream>

#include "save.h"

using namespace std;

class Dog
{
	int a;
public:
	Dog() {};
	//Dog(int i) { a = i; };
	Dog(int i) : a{ i } {};

	friend ostream& operator<<(ostream&, const Dog& );
};

ostream& operator<<(ostream& os, const Dog& d)
{
	os << d.a;
	return os;
}

template<typename T>
void change(T& a, T& b)
{
	T tmp{};
	tmp = a;
	// 클래스가 선언될 때, operator=은 자동으로 생성된다. 
	// a.operator=(b);
	a = b;
	b = tmp;
}

// [문제] main()을 변경하면 안된다.
// 실행하면 a와 b의 값이 서로 바껴야 한다.

int main()
{
	Dog a{ 1 };
	Dog b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;

	save("소스.cpp");
}



===================================================================
파일 이름 : 소스.cpp
파일크기 : 1128
저장 시간 : 2022-03-03 12:20:21 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일
// 수78목23 (1주 2일)
// 
// 
// 할일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
// &의 의미를 복습
// class를 복습
// 
//----------------------------------------------------------------------------------------

#include <iostream>

#include "save.h"

using namespace std;

class Dog
{
	int a;
public:
	Dog() {};
	//Dog(int i) { a = i; };
	Dog(int i) : a{ i } {};

	//friend ostream& operator<<(ostream&, const Dog& );
	
	// 야매기술
	operator int() {
		return a;
	}
};

//ostream& operator<<(ostream& os, const Dog& d)
//{
//	os << d.a;
//	return os;
//}

template<typename T>
void change(T& a, T& b)
{
	T tmp{};
	tmp = a;
	// 클래스가 선언될 때, operator=은 자동으로 생성된다. 
	// a.operator=(b);
	a = b;
	b = tmp;
}

// [문제] main()을 변경하면 안된다.
// 실행하면 a와 b의 값이 서로 바껴야 한다.

int main()
{
	Dog a{ 1 };
	Dog b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;

	save("소스.cpp");
}



===================================================================
파일 이름 : 소스.cpp
파일크기 : 926
저장 시간 : 2022-03-10 10:38:44 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 10일 목요일
// 수78목23 (2주 1일)
// 
// 
// 할일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
// &의 의미를 복습
// class를 복습
// 
//----------------------------------------------------------------------------------------

#include <iostream>

#include "save.h"

using namespace std;

template<typename T>
void change(T& a, T& b)
{
	T tmp{};
	tmp = a;
	// 클래스가 선언될 때, operator=은 자동으로 생성된다. 
	// a.operator=(b);
	a = b;
	b = tmp;
}

// [문제] change를 한번만 선언하고 정의하여 
// main이 수정 없이 실행되도록 해보자.

int main()
{
	{
		
		int a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << endl;
	}
	{
		string a{ "1"s }, b{ "2"s };
		change(a, b);
		cout << a << ", " << b << endl;
	}

	save("소스.cpp");
}



===================================================================
파일 이름 : 소스.cpp
파일크기 : 1269
저장 시간 : 2022-03-10 11:46:28 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 10일 목요일
// 수78목23 (2주 1일)
// 
// 
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 C++ 핵심 keyword
//		  - 이러한 방식의 코딩을 generic 
// 
// 많은 데이터를 다루는 연습 - 파일
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <ctime>
#include "save.h"

using namespace std;

// [문제] 엔진과 분포를 이용하여 임의의 값을 갖는 int 1000개를 화면에 출력하라.
random_device rd;
default_random_engine dre{ rd() };

int main()
{
	std::uniform_int_distribution uid;

	for (int i = 0; i < 1000; ++i)
	{
		cout << uid(dre) << "\t";
	}
	cout << endl;

	save("소스.cpp");
}

//int main()
//{
//
//	srand(time(NULL));
//
//	int a[1000]{};
//
//	for (int i : a)
//	{
//		i = rand();
//		cout << i << "\t";
//	}
//
//	//save("소스.cpp");
//}

//int main()
//{
//	std::random_device rd;
//	std::mt19937 gen(rd());
//	std::uniform_int_distribution<int> dis(0, 10000000);
//
//	int a[1000]{};
//
//	for (int i : a)
//	{
//		i = dis(gen);
//		cout << i << "\t";
//	}
//
//	//save("소스.cpp");
//}



===================================================================
파일 이름 : 소스.cpp
파일크기 : 1298
저장 시간 : 2022-03-10 11:54:42 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 10일 목요일
// 수78목23 (2주 1일)
// 
// 
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 C++ 핵심 keyword
//		  - 이러한 방식의 코딩을 generic 
// 
// 많은 데이터를 다루는 연습 - 파일
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;

// [문제] int의 최댓값 출력

int main()
{
	

	//1
	cout << "int의 최댓값 : " << numeric_limits<int>::max() << endl;
	cout << "unsigned int의 최댓값 : " << numeric_limits<unsigned int>::max() << endl;

	//2
	int num = 0x7F'FF'FF'FF;
	cout << "int의 최댓값 : " << num << endl;

	//3
	cout << "int의 최댓값 : " << INT_MAX << endl;

	save("소스.cpp");
}

//int main()
//{
//
//	srand(time(NULL));
//
//	int a[1000]{};
//
//	for (int i : a)
//	{
//		i = rand();
//		cout << i << "\t";
//	}
//
//	//save("소스.cpp");
//}

//int main()
//{
//	std::random_device rd;
//	std::mt19937 gen(rd());
//	std::uniform_int_distribution<int> dis(0, 10000000);
//
//	int a[1000]{};
//
//	for (int i : a)
//	{
//		i = dis(gen);
//		cout << i << "\t";
//	}
//
//	//save("소스.cpp");
//}



===================================================================
파일 이름 : 소스.cpp
파일크기 : 1027
저장 시간 : 2022-03-16 15:31:05 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일
// 수78목23 (2주 2일)
// 
// 
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 C++ 핵심 keyword
//		  - 이러한 방식의 코딩을 generic 
// 
// 많은 데이터를 다루는 연습 - 파일
// 숙제 - 파일입출력 알아보기
// 다음시간 질문 - int 1000개를 저장하려면 몇 바이트가 필요할까?
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include "save.h"

using namespace std;

// [문제] 엔진과 분포를 이용하여 임의의 값을 갖는 int 1000개를 화면에 출력하라.
// 마지막 int값은 1515792703을 출력
// 1515792703

int main()
{
	ifstream in{ "random int 1000s.txt" };

	if (!in)
	{
		cout << "파일을 열 수 없습니다." << endl;
		return 0;
	}
	int num;

	for (int i = 0; i < 1000; ++i)
	{
		in >> num;
		cout << num << "\t";
	}
	


	save("소스.cpp");
}


===================================================================
파일 이름 : 소스.cpp
파일크기 : 1543
저장 시간 : 2022-03-16 15:53:18 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일
// 수78목23 (2주 2일)
// 
// 
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 C++ 핵심 keyword
//		  - 이러한 방식의 코딩을 generic 
// 
// 많은 데이터를 다루는 연습 - 파일
// 숙제 - 파일입출력 알아보기
// 다음시간 질문 - int 1000개를 저장하려면 몇 바이트가 필요할까?
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <cmath>
#include "save.h"

using namespace std;

// [문제] 엔진과 분포를 이용하여 임의의 값을 갖는 int 1000개를 화면에 출력하라.
// 가장 큰 값을 찾아 화면에 출력해보자.

int main()
{
	ifstream in{ "random int 1000s.txt" };

	if (!in)
	{
		cout << "파일을 열 수 없습니다." << endl;
		return 0;
	}

	// 교수님
	{
		int num;
		int max{ numeric_limits<int>::min() };

		for (int i{}; i < 1000; ++i)
		{
			in >> num;
			if (max < num) max = num;
		}

		cout << max << endl;
	}

	// 교수님 2

	cout << *max_element(istream_iterator<int>{in}, {}) << endl;

	//1
	{
		int num;
		int M = 0;
		for (int i = 0; i < 1000; ++i)
		{
			in >> num;
			M = std::max(M, num);
		}
		cout << M << endl;
	}
	//2
	{
		int num;
		int M = 0;
		for (int i = 0; i < 1000; ++i)
		{
			in >> num;
			if (M < num) M = num;
		}

		cout << M << endl;
	}

	// ?? 왜다르지?
	// 2147255967
	// 1515792703

	save("소스.cpp");
}



===================================================================
파일 이름 : 소스.cpp
파일크기 : 938
저장 시간 : 2022-03-16 16:03:59 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일
// 수78목23 (2주 2일)
// 
// 
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 C++ 핵심 keyword
//		  - 이러한 방식의 코딩을 generic 
// 
// 많은 데이터를 다루는 연습 - 파일
// 숙제 - 파일입출력 알아보기
// 다음시간 질문 - int 1000개를 저장하려면 몇 바이트가 필요할까?
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <cmath>
#include "save.h"

using namespace std;

// [문제] 
// int 1000개를 저장하려면 메모리 몇 바이트가 필요합니까?
// 답
// 대답할 수 없다. 제한이 없다. 왜 없을까?
//	-> 상황에 따라 다르다.
//	-> 그렇지만 int 메모리 자체 비트를 그대로 기록하고 읽어온다면 어떤 상황에서도 4000 Byte면 충분할 것이다. 

int main()
{

	save("소스.cpp");
}



===================================================================
파일 이름 : 소스.cpp
파일크기 : 1158
저장 시간 : 2022-03-16 16:19:21 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일
// 수78목23 (2주 2일)
// 
// 
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 C++ 핵심 keyword
//		  - 이러한 방식의 코딩을 generic 
// 
// 많은 데이터를 다루는 연습 - 파일
// 숙제 - 파일입출력 알아보기
// 다음시간 질문 - int 1000개를 저장하려면 몇 바이트가 필요할까?
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

using namespace std;

// [문제] 
// int 1000개를 파일에 메모리 그대로 기록하라. 파일 이름은 그대로 유지하라.

int main()
{
	ofstream out{ "random int 1000s.txt", ios::binary };
	// 이상한점?
	// 4000 바이트일줄 알았는데 4004 바이트가 나왔다. 왜?
	// 윈도우는 파일을 기록할 때 어떤 데이터에서는 1바이트를 2바이트로 저장한다 그것은 아스키 코드 enter. CR,LF를 누르면 2바이트로 저장한다.
	// ios::binary 를 붙이면 4바이트가 사라진다.

	int num;

	for (int i = 0; i < 1000; ++i)
	{
		num = i + 1;
		out.write((const char*)&num, sizeof(num));
	}

	save("소스.cpp");
}



===================================================================
파일 이름 : 소스.cpp
파일크기 : 1886
저장 시간 : 2022-03-16 17:17:21 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일
// 수78목23 (2주 2일)
// 
// 
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 C++ 핵심 keyword
//		  - 이러한 방식의 코딩을 generic 
// 
// 많은 데이터를 다루는 연습 - 파일
// 숙제 - 파일입출력 알아보기
// 다음시간 질문 - int 1000개를 저장하려면 몇 바이트가 필요할까?
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <format>		// c++20
#include <cmath>
#include <array>
#include "save.h"

using namespace std;

// [문제] 
// 랜덤 값 int 1000개를 파일에 메모리 그대로 기록하라. 
// 이 때, 바이너리 모드로 기록하면 쓸데없는 변환을 안하도록 할 수 있다.
// random int 1000s.txt 파일에 binary 모드와 write 함수를 사용하여 기록되었다.
// 읽어서 가장 큰 값을 찾아 화면에 출력하라.

int main()
{
	ifstream in{ "random int 1000s.txt", ios::binary };
	

	{
		/*int num;
		int max{ numeric_limits<int>::min() };

		for (int i = 0; i < 1000; ++i)
		{
			in.read((char*)&num, sizeof(num));
			max = std::max(num, max);
		}
		cout << max << endl;*/
	}

	{
		int num[1'000];
		in.read((char*)num, sizeof(int) * 1'000);
		{
			/*for (int num : num)
				cout << num << "\t";
			cout << endl;*/
		}
		{
			for (int num : num)
				cout << format("{:20}", num);
		}
		cout << endl;
		cout << *max_element(begin(num), end(num)) << endl;
	}
	{
		//int num[1'000];
		array<int, 1000> num;

		in.read((char*)num.data(), sizeof(int) * 1'000);
		{
			/*for (int num : num)
				cout << num << "\t";
			cout << endl;*/
		}
		{
			for (int num : num)
				cout << format("{:20}", num);
		}
		cout << endl;
		cout << *max_element(begin(num), end(num)) << endl;
	}

	save("소스.cpp");
}



===================================================================
파일 이름 : 소스.cpp
파일크기 : 873
저장 시간 : 2022-03-17 11:31:25 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 17일 목요일
// 수78목23 (3주 1일)
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;

// [문제] 
// 사용자 입력을 받아 원하는 만큼 int를 저장할 메모리를 확보하고 1부터 증가하는 정수로 메모리를 채워라.
// 전체 합계를 출력하라.

int main()
{
	save("소스.cpp");

	while(true) 
	{
		int num;
		cout << "몇 개를 원하십니까? : ";
		cin >> num;

		unique_ptr<int[]> p{new int[num]};

		for (int i = 0; i < num; ++i)
		{
			p[i] = i + 1;
		}

		long long sum{};

		for (int i = 0; i < num; ++i)
		{
			sum += p[i];
		}

		cout << "1 부터" << num << "까지의 합계 : " << sum << endl << endl;

		p.reset(nullptr);
	}
}



===================================================================
파일 이름 : 소스.cpp
파일크기 : 1040
저장 시간 : 2022-03-17 12:05:28 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 17일 목요일
// 수78목23 (3주 1일)
// 
// - 지난 시간 배운 것 - 앞으로 int[100] 대신에 -> array<int,100> 사용하자
// - 오늘 알아본 것 - 앞으로 int* 대신에 -> unique_ptr<int> 사용하자
//					- int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자 
//----------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;

// 메모리 관찰용 초미니 Dog를 만들자

struct Dog
{
	Dog() { cout << "Dog 생성자 호출" << endl; }
	~Dog() { cout << "Dog 소멸자 호출" << endl; }
};

// [문제] 
// 
// 

void f()
{
	throw 1;
}

int main()
{
	save("소스.cpp");

	/*for (int i = 0; i < 3; ++i)
	{
		Dog* p = new Dog;
		delete p;
	}*/
	unique_ptr<Dog[]>p{new Dog[3]};

	// 여기서 비정상 종료
	try
	{
		f();		// 예외를 던진다
	}
	catch (...)		// ... elipses
	{
		cout << "예외를 잡았다" << endl;
		return 0;
	}
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 802
저장 시간 : 2022-03-17 12:09:09 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 17일 목요일
// 수78목23 (3주 1일)
// 
// - 지난 시간 배운 것 - 앞으로 int[100] 대신에 -> array<int,100> 사용하자
// - 오늘 알아본 것 - 앞으로 int* 대신에 -> unique_ptr<int> 사용하자
//					- int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

using namespace std;

// [문제] 이 "소스.cpp" 파일의 소문자를 전부 대문자로 바꿔
// "소스 대문자.cpp"로 저장하라.

int main()
{
	ifstream in("소스.cpp");

	char c;
	while (in >> noskipws >> c)
	{
		c = toupper(c);
		cout << c << endl;
	}

	save("소스.cpp");
}


===================================================================
파일 이름 : 소스.cpp
파일크기 : 829
저장 시간 : 2022-03-17 12:10:23 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 17일 목요일
// 수78목23 (3주 1일)
// 
// - 지난 시간 배운 것 - 앞으로 int[100] 대신에 -> array<int,100> 사용하자
// - 오늘 알아본 것 - 앞으로 int* 대신에 -> unique_ptr<int> 사용하자
//					- int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

using namespace std;

// [문제] 이 "소스.cpp" 파일의 소문자를 전부 대문자로 바꿔
// "소스 대문자.cpp"로 저장하라.

int main()
{
	ifstream in("소스.cpp");
	ofstream out("소스 대문자.cpp");

	char c;
	while (in >> noskipws >> c)
	{
		c = toupper(c);
		out << c ;
	}

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1250
저장 시간 : 2022-03-23 16:08:32 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 23일 수요일
// 수78목23 (3주 2일)
// 
// 지난 시간 : RAII / stack unwinding
// 
// 이번 시간 : 호출가능(Callable) 타입 -  예제는 정렬(sort)
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// String 클래스를 만들어 나가면서 STL을 이해해본다.
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

using namespace std;

// [문제] 이 "소스.cpp" 파일의 소문자를 전부 대문자로 바꿔
// "소스 대문자.cpp"로 저장하라.

int main()
{


	ifstream in("소스.cpp");
	ofstream out("소스 대문자.cpp");

	in >> noskipws;

	if(false) {
		// c 함수 사용 방식
		char c;
		while (in >> c)
		{
			if (islower(c))
				c = toupper(c);
			out << c;
		}
	}
	{
		// STL 사용 방식
		//transform(어디부터, 어디까지를, 저기에 저장, 이렇게 바꿔서)
		//transform(istreambuf_iterator<char>{in}, {}, ostreambuf_iterator{ out }, toupper);
		transform(istreambuf_iterator<char>{in}, {}, ostreambuf_iterator{ out }, [](char c) {return toupper(c); });

	}
	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1282
저장 시간 : 2022-03-23 16:10:58 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 23일 수요일
// 수78목23 (3주 2일)
// 
// 지난 시간 : RAII / stack unwinding
// 
// 이번 시간 : 호출가능(Callable) 타입 -  예제는 정렬(sort)
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// String 클래스를 만들어 나가면서 STL을 이해해본다.
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

using namespace std;

// [문제] 이 "소스.cpp" 파일의 
// 숫자를 *로 바꿔라.
// "소스 대문자.cpp"로 저장하라.

int main()
{


	ifstream in("소스.cpp");
	ofstream out("소스 대문자.cpp");

	in >> noskipws;

	if(false) {
		// c 함수 사용 방식
		char c;
		while (in >> c)
		{
			if (islower(c))
				c = toupper(c);
			out << c;
		}
	}
	{
		// STL 사용 방식
		//transform(어디부터, 어디까지를, 저기에 저장, 이렇게 바꿔서)
		//transform(istreambuf_iterator<char>{in}, {}, ostreambuf_iterator{ out }, toupper);
		transform(istreambuf_iterator<char>{in}, {}, ostreambuf_iterator{ cout }, [](char c) {
			if (isdigit(c))
				c = '*';
			return c; 
			});

	}
	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1492
저장 시간 : 2022-03-23 16:53:19 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 23일 수요일
// 수78목23 (3주 2일)
// 
// 지난 시간 : RAII / stack unwinding
// 
// 이번 시간 : 호출가능(Callable) 타입 -  예제는 정렬(sort)
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// String 클래스를 만들어 나가면서 STL을 이해해본다.
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <array>
#include <format>
#include <random>
#include <algorithm>
#include "save.h"

using namespace std;

// [문제] 랜덤값을 갖는 int 100개를 생성하라.
// 오름차순으로 정렬하라.
// 화면에 정렬된 int 100개를 출력하라.

default_random_engine dre;

int main()
{
	std::uniform_int_distribution uid(0,100);

	array<int, 100> ai;

	{
		/*for (int i = 0; i < ai.size(); ++i)
		{
			ai[i] = uid(dre);
		}*/
		for (int& random_number : ai)
		{
			random_number = uid(dre);
		}
		cout << "정렬 전 데이터" << endl;
		for (int num : ai)
		{
			cout << format("{:4}", num);
		}
		cout << endl << "정렬 후 데이터" << endl;
		sort(ai.begin(), ai.end());
		for (int num : ai)
		{
			cout << format("{:4}", num);
		}
	}

	{
		//vector<int> vi;

		/*for (int i = 0; i < 100; ++i)
		{
			vi.push_back(uid(dre));
		}

		sort(vi.begin(), vi.end());

		for (int i : vi)
			cout << i << endl;*/
	}
	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 809
저장 시간 : 2022-03-23 17:10:23 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 23일 수요일
// 수78목23 (3주 2일)
// 
// 지난 시간 : RAII / stack unwinding
// 
// 이번 시간 : 호출가능(Callable) 타입 -  예제는 정렬(sort)
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// String 클래스를 만들어 나가면서 STL을 이해해본다.
// 
//----------------------------------------------------------------------------------------

#include <iostream>

#include "save.h"

using namespace std;

// [문제] 

void f()
{
	cout << "함수가 호출되었다" << endl;
}

int main()
{
	f();

	// f의 자료형을 출력하라.
	cout << typeid(f).name() << endl;
	cout << addressof(f) << endl;
	cout << addressof(main) << endl;

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1173
저장 시간 : 2022-03-24 10:42:54 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 24일 목요일
// 수78목23 (4주 1일)
// 
// 지난 시간 : RAII / stack unwinding
// 
// 이번 시간 : 호출가능(Callable) 타입 -  예제는 정렬(sort)
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// String 클래스를 만들어 나가면서 STL을 이해해본다.
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"

using namespace std;

// [문제] 

void jump()
{
	cout << "짬푸!" << endl;
}

void slide()
{
	cout << "슬라이드!" << endl;
}

int g;

int main()
{
	// 확인 : 함수의 이름은 함수가 기록되어 있는 CODE 세그먼트의 시작번지이다.
	// 함수들은 유사한 메모리에 기록되어 있음을 알 수 있다.

	cout << "main : " << addressof(main) << endl;
	cout << "save : " << addressof(save) << endl;
	cout << "jump : " << addressof(jump) << endl;
	cout << "slide : " << addressof(slide) << endl;

	int n;
	cout << "STACK : " << addressof(n) << endl;
	cout << "DATA : " << addressof(g) << endl;

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 774
저장 시간 : 2022-03-24 10:45:57 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 24일 목요일
// 수78목23 (4주 1일)
// 
// 지난 시간 : RAII / stack unwinding
// 
// 이번 시간 : 호출가능(Callable) 타입 -  예제는 정렬(sort)
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// String 클래스를 만들어 나가면서 STL을 이해해본다.
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;

// [문제] 

int main()
{
	int n[25000];
	for (int i = 0; i < 25000; ++i)
	{
		n[i] = i * i;
	}
	cout << "메인 호출" << endl;

	for (int i = 0; i < 25000; ++i)
		cout << i << endl;

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 881
저장 시간 : 2022-03-24 11:00:58 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 24일 목요일
// 수78목23 (4주 1일)
// 
// 지난 시간 : RAII / stack unwinding
// 
// 이번 시간 : 호출가능(Callable) 타입 -  예제는 정렬(sort)
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// String 클래스를 만들어 나가면서 STL을 이해해본다.
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;

// [문제] 
// 호출가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나?
// 1. 함수 - CODE 세그먼트에 기록된 명령어 집합의 시작번지
// 2. 람다 - 이름 없는 함수
//


int main()
{
	//lambda
	cout << typeid([]() {
		cout << "안녕! 난 람다야! 하위!" << endl;
		}()).name() << endl;



	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1450
저장 시간 : 2022-03-24 11:08:28 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 24일 목요일
// 수78목23 (4주 1일)
// 
// 지난 시간 : RAII / stack unwinding
// 
// 이번 시간 : 호출가능(Callable) 타입 -  예제는 정렬(sort)
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// String 클래스를 만들어 나가면서 STL을 이해해본다.
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;

// [문제] 
// 호출가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나?
// 1. 함수 - CODE 세그먼트에 기록된 명령어 집합의 시작번지
// 2. 람다 - 이름 없는 함수
//

class Cat {};

auto x2 = []() {
	cout << "안녕! 난 람다야! 하위!" << endl;
};

int main()
{
	class Dog {};




	//lambda
	auto x = []() {
		cout << "안녕! 난 람다야! 하위!" << endl;
	};

	auto x1 = []() {
		cout << "안녕! 난 람다야! 하위!" << endl;
	};

	cout << typeid(Dog).name() << endl;
	// class `int __cdecl main(void)'::`2'::Dog
	cout << typeid(Cat).name() << endl;
	// class Cat
	cout << typeid(x).name() << endl;
	//class `int __cdecl main(void)'::`2'::<lambda_1>
	cout << typeid(x1).name() << endl;
	//class `int __cdecl main(void)'::`2'::<lambda_2>
	cout << typeid(x2).name() << endl;
	//class x2::<lambda>

	// 람다함수는 클래스로 구현되어 있음.


	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1126
저장 시간 : 2022-03-24 11:18:19 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 24일 목요일
// 수78목23 (4주 1일)
// 
// 지난 시간 : RAII / stack unwinding
// 
// 이번 시간 : 호출가능(Callable) 타입 -  예제는 정렬(sort)
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// String 클래스를 만들어 나가면서 STL을 이해해본다.
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <array>

#include "save.h"

using namespace std;

// [문제] 
// 호출가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나?
// 1. 함수 - CODE 세그먼트에 기록된 명령어 집합의 시작번지
// 2. 람다 - 이름 없는 함수
// 3. 클래스 객체 - 
//

class Dog {
public:
	bool operator()(int a, int b) {
		cout << "Dog 호출" << endl;
		cout << a << " 비교 " << b << endl;
		return a > b;
	}
};

int main()
{
	array<int, 5> arr{1,3,5,2,4};

	sort(arr.begin(), arr.end(), Dog());
	for (int i : arr)
	{
		cout << i << " ";
	}
	cout << endl;

	save("소스.cpp");
}

===================================================================
파일 이름 : 소스.cpp
파일크기 : 1138
저장 시간 : 2022-03-24 11:39:14 GMT+9
//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 3월 24일 목요일
// 수78목23 (4주 1일)
// 
// 지난 시간 : RAII / stack unwinding
// 
// 이번 시간 : 호출가능(Callable) 타입 -  예제는 정렬(sort)
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// String 클래스를 만들어 나가면서 STL을 이해해본다.
// 
//----------------------------------------------------------------------------------------

#include <iostream>
#include <functional>

#include "save.h"

using namespace std;

// [문제] 
// 호출가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나?
// 1. 함수포인터 - CODE 세그먼트에 기록된 명령어 집합의 시작번지
// 2. 람다 - 이름 없는 함수, 실제는 클래스로 구현된다.
// 3. operator()을 오버로딩한 클래스
// 4. 멤버 함수를 가리키는 포인터
// 
// - 호출 가능 타입의 종류가 무한하기 때문에
// 모든 호출가능타입을 대표하는 클래스를 만들었다. : function
//

int add(int a, int b)
{
	return a + b;
}


int main()
{
	function<int(int, int)> f;

	f = add;

	cout << f(3, 3) << endl;


	save("소스.cpp");
}