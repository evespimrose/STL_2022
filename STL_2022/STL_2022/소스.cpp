//----------------------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일
// 수78목23 (6주 2일)
//
// RVO(Return value optimization), Copy Ellision
// 
// 컨테이너 -> Containers are objects that store other objects
// 
// 컨테이너
// Sequence container		- 임의의 위치에 원소의 값을 읽고 쓰거나 추가할 수 있다.
//		array				- 유일하게 원소 갯수가 고정됨.
//		vector				- 깊게 알아볼 가치가 있는 컨테이너
//							- 원소를 마지막 위치에 추가하는 데 특화되어 있다 (O(1))
//		deque
//		foward_list
//		list
// 
// 예정 - 중간시험 4.20(수) (7주 2일)
// 시험시간 70분 1745~
// 
//----------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <vector>
#include <deque>

#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// deque는 원소를 같은 공간에 있는것 "처럼" 관리한다. push_back, push_front 동작이 매우 간편함. 하지만
// 덱은 원소를 n개씩 담는 리스트이다. 메모리가 붙어있는 듯이 보이지만 데이터를 "블럭"(데이터가 n개씩 모인) 단위로 관리.
// 벡터는 access가 O(1) , 리스트는 임의의 위치 삭제가 O(1) access는 O(n). 이 둘의 중간이 덱.
// 마치 연속된 메모리 인것처럼 access도 상수시간이고(상수시간인 척 하는거지만 상수시간임.), 리스트처럼 임의의 위치 및 삭제도 상수시간이다.
// "실제 그렇지는 않다"는 것에 주의할것.
// 벡터는 메모리 할당구역 이상의 인수를 넣을 때 통째로 들어서 새로운 공간으로 이사간다.
// 덱의 핵심 특징은 한번 확보한 메모리 공간이 다른 곳으로 이동하지는 않는다.
// 덱은 삽입하거나 삭제하더라도 절대 원소를 가리키던 포인터나 레퍼런스가 무효화되지 않는다.
// 덱은 연속적으로 저장되지 않았으므로 주의.
// 

// [문제] vector는 연속인데, deque는 연속이 아니라고?
// 주소를 확인해보면 됨.

int main()
{
	deque<int> d{ 1,2,3,4,5 };
	for (int i = 0; i < d.size(); ++i)
		cout << d[i] << endl;
	cout << sizeof(d) << endl; // 벡터 : 24, 덱 : 40. 왜? 

	//save("소스.cpp");
}